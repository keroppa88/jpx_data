<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>株価指数 + 部門別売買動向チャート</title>
  <style>
    :root{
      --bg:#f5f5f7;
      --card:#ffffff;
      --text:#1f2328;
      --muted:#6b7280;
      --axisDark:#6b7280;
      --line:#e5e7eb;
      --chip:#f3f4f6;
      --shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    body{
      margin:0; padding:16px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg); color:var(--text);
    }
    .wrap{ width:100%; margin:0 auto; }
    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:14px; box-shadow:var(--shadow);
      padding:14px 16px;
      max-width:1400px;
      margin:0 auto;
    }
    .header{
      display:flex; align-items:baseline; gap:12px; flex-wrap:wrap;
    }
    .header h1{ margin:0; font-size:16px; letter-spacing:0.2px; }
    .sub{ font-size:12px; color:var(--muted); }
    .headerRight{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .rows{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

    .controls{
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .group{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fafafa;
      border-radius:12px;
    }
    .label{ font-weight:700; font-size:12px; color:#374151; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      background:var(--chip);
      border-radius:999px;
      font-size:12px; color:#111827;
      white-space:nowrap;
    }
    .chip .muted{ color:var(--muted); }

    .grid2{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .chartCard{ border:1px solid var(--line); border-radius:12px; background:#fff; overflow:hidden; }
    .chartHead{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background:#fafafa;
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    .chartTitle{ font-weight:700; font-size:13px; color:#111827; margin-right:auto; }

    .legend{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .legend-item{ display:flex; align-items:center; gap:6px; font-size:12px; color:#374151; }
    .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.15); }

    .selRow{
      display:flex;
      gap:8px;
      align-items:flex-start;
      width:100%;
      padding:8px 0;
    }
    #tseSelContainer, #idxSelContainer{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    #tseSelContainer.hidden, #idxSelContainer.hidden{
      display:none;
    }
    .sel{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:10px;
    }
    .sel .slot{
      width:16px;
      text-align:right;
      font-size:11px;
      color:var(--muted);
      flex:0 0 auto;
    }
    #idxSlotLabel{
      width:auto;
      text-align:left;
      white-space:nowrap;
    }
    select{
      min-width:180px;
      padding:5px 6px;
      border:1px solid #cfd4dc;
      border-radius:8px;
      background:#fff;
      font-size:12px;
    }
    .color-picker{
      width:28px;
      height:28px;
      border:1px solid #cfd4dc;
      border-radius:6px;
      padding:0;
      cursor:pointer;
      background:none;
    }
    .show-check{
      width:18px;
      height:18px;
      margin-left:4px;
      cursor:pointer;
      accent-color:#2563eb;
    }
    .sel.disabled{
      opacity:0.5;
    }
    .sel.disabled .slot{
      color:#9ca3af;
    }

    .canvasBox{ position:relative; background:#fff; }
    canvas{ display:block; width:100%; cursor:crosshair; }

    .toggle-btn{
      width:28px; height:28px;
      border:1px solid #cfd4dc;
      border-radius:6px;
      background:#fff;
      font-size:18px;
      font-weight:bold;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#374151;
      flex-shrink:0;
    }
    .toggle-btn:hover{
      background:#f3f4f6;
    }
    #idxChart{ height:240px; }
    #tseChart{ height:480px; }

    .tooltip{
      position:fixed;
      background:rgba(255,255,255,0.98);
      border:1px solid #9ca3af; padding:8px 10px; border-radius:10px;
      font-size:12px; pointer-events:none; display:none;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:1000; line-height:1.45; white-space:nowrap;
    }

    .help-btn{
      padding:6px 12px;
      border:1px solid #cfd4dc;
      border-radius:8px;
      background:#fff;
      font-size:12px;
      cursor:pointer;
      color:#374151;
      margin-left:12px;
    }
    .help-btn:hover{
      background:#f3f4f6;
    }

    .modal-overlay{
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.5);
      display:none;
      justify-content:center;
      align-items:center;
      z-index:2000;
    }
    .modal-overlay.show{
      display:flex;
    }
    .modal-content{
      background:#fff;
      border-radius:12px;
      padding:20px 24px;
      max-width:500px;
      width:90%;
      box-shadow:0 10px 40px rgba(0,0,0,0.2);
    }
    .modal-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:16px;
    }
    .modal-title{
      font-weight:700;
      font-size:16px;
      color:#111827;
    }
    .modal-close{
      background:none;
      border:none;
      font-size:24px;
      cursor:pointer;
      color:#6b7280;
      line-height:1;
    }
    .modal-close:hover{
      color:#111827;
    }
    .modal-body{
      font-size:13px;
      line-height:1.7;
      color:#374151;
    }
    .modal-body p{
      margin:0 0 10px 0;
    }
    .modal-body a{
      color:#2563eb;
      word-break:break-all;
    }
    .modal-body .section-title{
      font-weight:700;
      margin-top:16px;
      margin-bottom:8px;
      color:#111827;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <h1>株価指数 + 部門別売買動向チャート</h1>
        <span class="sub" id="status">読込中…</span>
      </div>

      <div class="rows">
        <div class="controls">
          <span class="chip" id="latestChip"><span class="muted">最新</span> -</span>
          <span class="chip" id="viewChip"><span class="muted">表示範囲</span> -</span>
          <label style="display:flex; align-items:center; gap:4px; margin-left:8px; font-size:12px; cursor:pointer;">
            <input type="checkbox" id="showDateLine" checked style="width:16px; height:16px; accent-color:#2563eb;">
            日付ライン
          </label>
          <label style="display:flex; align-items:center; gap:4px; margin-left:8px; font-size:12px; cursor:pointer;">
            <input type="checkbox" id="showFullDate" checked style="width:16px; height:16px; accent-color:#2563eb;">
            日付表示
          </label>
          <button class="help-btn" id="helpBtn">説明</button>
        </div>

        <div class="grid2">
          <!-- 株価指数チャート（プルダウン1つ） -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">株価指数</div>
              <div class="legend" id="idxLegend"></div>
              <button class="toggle-btn" id="idxToggleBtn" title="プルダウンの表示/非表示">－</button>
            </div>
            <div class="selRow" id="idxSelRow" style="padding:8px 12px;">
              <div id="idxSelContainer">
                <div class="sel">
                  <div class="slot" id="idxSlotLabel">銘柄</div>
                  <select id="idxSel1"></select>
                </div>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="idxChart"></canvas>
            </div>
          </div>

          <!-- 部門別売買動向チャート（プルダウン8個、色選択付き） -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">部門別売買動向</div>
              <div class="legend" id="tseLegend"></div>
              <button class="toggle-btn" id="tseToggleBtn" title="プルダウンの表示/非表示">－</button>
            </div>
            <div class="selRow" id="tseSelRow" style="padding:8px 12px;">
              <div id="tseSelContainer">
                <div class="sel"><div class="slot">1</div><select id="tseSel1"></select><input type="color" class="color-picker" id="tseColor1" value="#FF4B00"><input type="checkbox" class="show-check" id="tseCheck1" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">2</div><select id="tseSel2"></select><input type="color" class="color-picker" id="tseColor2" value="#005AFF"><input type="checkbox" class="show-check" id="tseCheck2" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">3</div><select id="tseSel3"></select><input type="color" class="color-picker" id="tseColor3" value="#03AF7A"><input type="checkbox" class="show-check" id="tseCheck3" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">4</div><select id="tseSel4"></select><input type="color" class="color-picker" id="tseColor4" value="#4DC4FF"><input type="checkbox" class="show-check" id="tseCheck4" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">5</div><select id="tseSel5"></select><input type="color" class="color-picker" id="tseColor5" value="#F6AA00"><input type="checkbox" class="show-check" id="tseCheck5" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">6</div><select id="tseSel6"></select><input type="color" class="color-picker" id="tseColor6" value="#990099"><input type="checkbox" class="show-check" id="tseCheck6" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">7</div><select id="tseSel7"></select><input type="color" class="color-picker" id="tseColor7" value="#84919E"><input type="checkbox" class="show-check" id="tseCheck7" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">8</div><select id="tseSel8"></select><input type="color" class="color-picker" id="tseColor8" value="#000000"><input type="checkbox" class="show-check" id="tseCheck8" checked title="表示/非表示"></div>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="tseChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <!-- 説明モーダル -->
    <div id="helpModal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <div class="modal-title">説明</div>
          <button class="modal-close" id="modalClose">&times;</button>
        </div>
        <div class="modal-body">
          <p>投資部門別売買動向をJPX・APIで取得。</p>
          <p><strong>更新タイミング</strong><br>
          投資部門別情報・週次の第4営業日＝木曜日の18:00頃<br>
          通常は木曜日、祝日等非営業日がある場合はその分後ろ倒し。</p>
          <div class="section-title">各項目定義</div>
    <p>総計<br>
        ├─自己計<br>
        └─委託計<br>
    　      ├─個人<br>
  　        ├─海外投資家<br>
   　       ├─証券会社<br>
   　       ├─投資信託<br>
   　       ├─金融<br>
    　      　├─生保・損保<br>
    　      　├─都銀・地銀等<br>
   　       　├─信託銀行<br>
   　       　├─その他金融機関<br>
   　       ├─法人<br>
   　       　├─事業法人<br>
   　       　└─その他法人</p>
        </div>
      </div>
    </div>
  </div>

<script>
/* ========= colors ========= */
const DEFAULT_COLORS = ["#FF4B00","#005AFF","#03AF7A","#4DC4FF","#F6AA00","#990099","#84919E","#000000"];
const MAX_DISPLAY = 700;
const TSE_SELECTION_COUNT = 8;

/* ========= TSEPrime: 英語列名 -> 日本語表示名 ========= */
const TSEPRIME_FIELD_MAP = {
  PropSell: "自己計_売",   PropBuy:"自己計_買",   PropTot:"自己計_合計",   PropBal:"自己計_差引",
  BrkSell: "委託計_売",    BrkBuy:"委託計_買",    BrkTot:"委託計_合計",    BrkBal:"委託計_差引",
  TotSell: "総計_売",      TotBuy:"総計_買",      TotTot:"総計_合計",      TotBal:"総計_差引",
  IndSell: "個人_売",      IndBuy:"個人_買",      IndTot:"個人_合計",      IndBal:"個人_差引",
  FrgnSell:"海外投資家_売",FrgnBuy:"海外投資家_買",FrgnTot:"海外投資家_合計",FrgnBal:"海外投資家_差引",
  SecCoSell:"証券会社_売", SecCoBuy:"証券会社_買", SecCoTot:"証券会社_合計", SecCoBal:"証券会社_差引",
  InvTrSell:"投資信託_売", InvTrBuy:"投資信託_買", InvTrTot:"投資信託_合計", InvTrBal:"投資信託_差引",
  BusCoSell:"事業法人_売", BusCoBuy:"事業法人_買", BusCoTot:"事業法人_合計", BusCoBal:"事業法人_差引",
  OthCoSell:"その他法人_売",OthCoBuy:"その他法人_買",OthCoTot:"その他法人_合計",OthCoBal:"その他法人_差引",
  InsCoSell:"生保・損保_売",InsCoBuy:"生保・損保_買",InsCoTot:"生保・損保_合計",InsCoBal:"生保・損保_差引",
  BankSell:"都銀・地銀等_売",BankBuy:"都銀・地銀等_買",BankTot:"都銀・地銀等_合計",BankBal:"都銀・地銀等_差引",
  TrstBnkSell:"信託銀行_売",TrstBnkBuy:"信託銀行_買",TrstBnkTot:"信託銀行_合計",TrstBnkBal:"信託銀行_差引",
  OthFinSell:"その他金融機関_売",OthFinBuy:"その他金融機関_買",OthFinTot:"その他金融機関_合計",OthFinBal:"その他金融機関_差引"
};

/* 差引項目のリスト（累積計算用） */
const BAL_FIELDS = [
  "自己計_差引", "委託計_差引", "総計_差引", "個人_差引",
  "海外投資家_差引", "証券会社_差引", "投資信託_差引", "事業法人_差引",
  "その他法人_差引", "生保・損保_差引", "都銀・地銀等_差引", "信託銀行_差引", "その他金融機関_差引"
];

/* ========= state ========= */
let idxRows = [];
let tseRows = [];
let idxDates = [];
let tseDates = [];
let globalDates = [];

let displayCount = 200;
let offsetX = 0;
let showDateLine = true;
let showFullDate = true;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;
let dragCanvas = null;

let idxCanvas, idxCtx, tseCanvas, tseCtx, tooltip;

let idxAvail = [];
let tseAvail = [];

let idxKey = "";
let tseKeys = new Array(TSE_SELECTION_COUNT).fill("");
let tseColors = [...DEFAULT_COLORS];
let tseVisible = new Array(TSE_SELECTION_COUNT).fill(true);

let idxData = null;
let tseData = null;

/* ========= helpers ========= */
function cleanHeaderValue(s){
  return String(s ?? "")
    .replace(/^\uFEFF/, "")
    .replace(/^"+|"+$/g, "")
    .trim();
}

function toNum(s){
  if(s==null) return NaN;
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim());
}
function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}
function uniqSorted(arr){
  const set = new Set(arr);
  const out = Array.from(set);
  out.sort((a,b)=>String(a).localeCompare(String(b)));
  return out;
}
function buildDateList(rows){
  const set = new Set();
  for(const r of rows){ if(r && r.date) set.add(r.date); }
  const arr = Array.from(set);
  arr.sort((a,b)=>{
    const ta=new Date(a).getTime(), tb=new Date(b).getTime();
    if(!Number.isNaN(ta) && !Number.isNaN(tb)) return ta-tb;
    return String(a).localeCompare(String(b));
  });
  return arr;
}
function buildGlobalDates(idxRows, tseRows){
  return buildDateList(idxRows.concat(tseRows));
}
function getVisibleWindowForDates(dates){
  const n = dates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const startRaw = n - count - localOffset;
  const endRaw = startRaw + count;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realDates = (start < end) ? dates.slice(start, end) : [];
  const realLen = realDates.length;

  const padN = count - realLen;
  const pads = new Array(Math.max(0,padN)).fill("");

  const visibleDates = pads.concat(realDates);
  const visibleAbsIndices = new Array(Math.max(0,padN)).fill(null).concat(
    Array.from({length: realLen}, (_,i)=> start + i)
  );
  return { visibleDates, visibleAbsIndices, startIndex: start, endIndex: end };
}
function buildDateIndex(dates){
  const map = new Map();
  dates.forEach((d,i)=>{ map.set(d, i); });
  return map;
}
function mapVisibleDatesToAbsIndices(dateIndex, visibleDates){
  return visibleDates.map(d => (d && dateIndex && dateIndex.has(d) ? dateIndex.get(d) : null));
}
function updateTopChips(){
  const latestEl = document.getElementById("latestChip");
  const viewEl = document.getElementById("viewChip");

  // 両チャートで統一された時系列を使用
  const baseDates = getBaseDates();

  if(!baseDates || baseDates.length===0){
    latestEl.innerHTML = `<span class="muted">最新</span> -`;
    viewEl.innerHTML = `<span class="muted">表示範囲</span> -`;
    return;
  }
  latestEl.innerHTML = `<span class="muted">最新</span> ${baseDates[baseDates.length-1]}`;

  // 表示範囲を計算
  const n = baseDates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const start = Math.max(0, n - count - localOffset);
  const end = Math.min(n, start + count);

  const startDate = baseDates[start] || null;
  const endDate = baseDates[end - 1] || null;
  viewEl.innerHTML = `<span class="muted">表示範囲</span> ${startDate && endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}
function syncCountControls(){
  // スライダーは廃止
}
function bindControls(){
  // 日付ラインチェックボックス
  const dateLineCheck = document.getElementById('showDateLine');
  dateLineCheck.checked = showDateLine;
  dateLineCheck.addEventListener('change', ()=>{
    showDateLine = dateLineCheck.checked;
    redrawAll();
  });

  // 日付表示チェックボックス（日/月切替）
  const fullDateCheck = document.getElementById('showFullDate');
  fullDateCheck.checked = showFullDate;
  fullDateCheck.addEventListener('change', ()=>{
    showFullDate = fullDateCheck.checked;
    redrawAll();
  });
}

/* ========= encoding-safe fetch ========= */
async function fetchTextAutoEncoding(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`${url} fetch失敗: ${res.status} ${res.statusText}`);
  const buf = await res.arrayBuffer();

  const tUtf8 = new TextDecoder("utf-8", {fatal:false}).decode(buf);
  if (tUtf8.includes("PubDate") || tUtf8.includes("公表日") || tUtf8.includes("PropSell") || tUtf8.includes("自己計") || tUtf8.includes("日付")) {
    return tUtf8;
  }
  const tSjis = new TextDecoder("shift-jis", {fatal:false}).decode(buf);
  return tSjis;
}

/* ========= parsers ========= */
function parsePtoCsvToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("PtoCSV_long.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxDate=header.indexOf("日付");
  const idxName=header.indexOf("商品名");
  const idxVal=header.indexOf("数値");
  if(idxDate<0||idxName<0||idxVal<0) throw new Error("PtoCSV_long.csv: 必須列(日付, 商品名, 数値)が見つかりません");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;
    const date=(cols[idxDate]||"").trim();
    const name=(cols[idxName]||"").trim();
    const value=toNum(cols[idxVal]);
    if(!date || !name || Number.isNaN(value)) continue;
    rows.push({date, name, value});
  }
  return rows;
}

function parseTsePrimeToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("TSEPrime.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxPubDate=header.indexOf("PubDate") >= 0 ? header.indexOf("PubDate") : header.indexOf("公表日");
  const idxSection=header.indexOf("Section") >= 0 ? header.indexOf("Section") : header.indexOf("市場名");
  if(idxPubDate<0) throw new Error("TSEPrime.csv: 必須列(PubDate/公表日)が見つかりません");

  const fieldDefs = Object.entries(TSEPRIME_FIELD_MAP)
    .map(([en, jp]) => ({ jp, idx: header.indexOf(en) >= 0 ? header.indexOf(en) : header.indexOf(jp) }))
    .filter(x => x.idx >= 0);

  if(fieldDefs.length===0) throw new Error("TSEPrime.csv: 数値列が見つかりません（Field map 不一致 / 文字化けの可能性）");

  let sectionFilter = null;
  if(idxSection >= 0){
    const hasTsePrime = lines.slice(1).some(line => {
      const cols = parseDelimitedLine(line, delim);
      const section = (cols[idxSection] || "").trim();
      return section === "TSEPrime";
    });
    if(hasTsePrime) sectionFilter = "TSEPrime";
  }

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;

    if(idxSection >= 0 && sectionFilter){
      const section=(cols[idxSection]||"").trim();
      if(section!==sectionFilter) continue;
    }

    const date=(cols[idxPubDate]||"").trim();
    if(!date) continue;

    for(const f of fieldDefs){
      const value=toNum(cols[f.idx]);
      if(Number.isNaN(value)) continue;
      rows.push({date, name: f.jp, value});
    }
  }
  return rows;
}

/* ========= list loaders ========= */
async function loadNameList(filename){
  async function fetchText(decoderName){
    const res = await fetch(filename, {cache:'no-store'});
    if(!res.ok) return null;
    const buf = await res.arrayBuffer();
    const dec = new TextDecoder(decoderName, {fatal:false});
    return dec.decode(buf);
  }
  function parseToNames(text, forBumonList = false){
    if(!text) return null;
    const lines = text.split(/\r?\n/);
    const out = [];
    let afterDisplayOrder = false;

    for(const raw of lines){
      let line = String(raw||"");
      line = line.replace(/^\uFEFF/, "");
      if(!line.trim() || line.trim().startsWith('#')) continue;

      // bumonlist.csvの場合、●表示順●以降のみを取得
      if(forBumonList){
        if(line.includes("●表示順●")){
          afterDisplayOrder = true;
          continue;
        }
        if(!afterDisplayOrder) continue;
      }

      const first = line.split(/\t|,/)[0].replace(/^"+|"+$/g,'');
      if(first.trim()) out.push(first); // トリムしないで保持（├─などのプレフィックス保持）
    }

    const seen = new Set();
    const uniq = [];
    for(const n of out){
      if(seen.has(n)) continue;
      seen.add(n);
      uniq.push(n);
    }
    return uniq.length ? uniq : null;
  }

  const isBumonList = filename.includes('bumonlist');

  const tUtf8 = await fetchText('utf-8');
  const nUtf8 = parseToNames(tUtf8, isBumonList);

  const tSjis = await fetchText('shift-jis');
  const nSjis = parseToNames(tSjis, isBumonList);

  if(!nUtf8 && !nSjis) return null;
  if(nUtf8 && !nSjis) return nUtf8;
  if(!nUtf8 && nSjis) return nSjis;
  return (nSjis.length > nUtf8.length ? nSjis : nUtf8);
}

/* ========= series building ========= */
// 指数データを週次日付（tseDates）にマッピング
// 各週次日付に対して、その日付以前で最も近い日次データの値を使用
function mapIdxToWeeklyDates(rows, key, weeklyDates, dailyDates){
  if(!key || !weeklyDates || weeklyDates.length === 0) return [];

  // 日次データのmapを作成
  const dailyMap = new Map();
  for(const r of rows){ if(r.name === key) dailyMap.set(r.date, r.value); }

  // 各週次日付に対応する値を探す
  const values = [];
  for(const wd of weeklyDates){
    // 完全一致があればそれを使用
    if(dailyMap.has(wd)){
      values.push(dailyMap.get(wd));
    } else {
      // 週次日付以前で最も近い日次日付を探す
      let closestValue = null;
      let closestDate = null;
      for(const dd of dailyDates){
        if(dd <= wd){
          if(!closestDate || dd > closestDate){
            closestDate = dd;
            if(dailyMap.has(dd)){
              closestValue = dailyMap.get(dd);
            }
          }
        }
      }
      values.push(closestValue);
    }
  }
  return values;
}

function buildIdxSeries(rows, key, weeklyDates, dailyDates){
  if(!key) return { dates: weeklyDates, series: [] };
  const values = mapIdxToWeeklyDates(rows, key, weeklyDates, dailyDates);
  return { dates: weeklyDates, series: [{ label: key, color: "#2563eb", width: 2, values }] };
}

// 合成項目の定義（複数の差引を合計して計算）
const COMPOSITE_FIELDS = {
  "金融_差引累計": ["生保・損保_差引", "都銀・地銀等_差引", "信託銀行_差引", "その他金融機関_差引"],
  "法人_差引累計": ["事業法人_差引", "その他法人_差引"]
};

function buildTseSeries(rows, keys, colors, dates, visible){
  const series = [];

  // 差引累計が1つでも選択されているかチェック
  const hasCumulative = keys.some((k, i) => k && k.endsWith("_差引累計") && visible[i]);

  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    if(!k) continue;
    if(!visible[i]) continue; // チェックが外れていたらスキップ

    // 累積計算かどうかをチェック
    const isCumulative = k.endsWith("_差引累計");

    // 差引累計がある場合、差引累計以外はスキップ
    if(hasCumulative && !isCumulative) continue;

    // 合成項目（金融_差引累計、法人_差引累計）かどうかをチェック
    const isComposite = COMPOSITE_FIELDS.hasOwnProperty(k);

    let values;
    if(isComposite){
      // 合成項目の場合、複数の差引を合計して累積計算
      const baseKeys = COMPOSITE_FIELDS[k];
      const maps = baseKeys.map(baseKey => {
        const m = new Map();
        for(const r of rows){ if(r.name === baseKey) m.set(r.date, r.value); }
        return m;
      });

      values = [];
      let cumulative = 0;
      for(let j=0; j<dates.length; j++){
        const d = dates[j];
        let sum = 0;
        let hasValue = false;
        for(const m of maps){
          const v = m.has(d) ? m.get(d) : null;
          if(v !== null){
            sum += v;
            hasValue = true;
          }
        }
        if(hasValue){
          cumulative += sum;
        }
        values.push(cumulative);
      }
    } else if(isCumulative){
      // 通常の累積計算
      const baseKey = k.replace("_差引累計", "_差引");
      const map = new Map();
      for(const r of rows){ if(r.name===baseKey) map.set(r.date, r.value); }

      values = [];
      let cumulative = 0;
      for(let j=0; j<dates.length; j++){
        const d = dates[j];
        const v = map.has(d) ? map.get(d) : null;
        if(v !== null){
          cumulative += v;
        }
        values.push(cumulative);
      }
    } else {
      // 通常の値
      const map = new Map();
      for(const r of rows){ if(r.name===k) map.set(r.date, r.value); }
      values = dates.map(d => (map.has(d) ? map.get(d) : null));
    }

    series.push({ label: k, color: colors[i] || DEFAULT_COLORS[i % DEFAULT_COLORS.length], width: 2, values, isCumulative: isCumulative || isComposite, slotIndex: i });
  }
  return { dates, series };
}

/* ========= draw ========= */
function renderLegend(elId, data){
  const box = document.getElementById(elId);
  if(!box) return;
  box.innerHTML = '';
  if(!data || !data.series || data.series.length===0) return;
  for(const s of data.series){
    const item = document.createElement('div');
    item.className = 'legend-item';
    const sw = document.createElement('span');
    sw.className = 'swatch';
    sw.style.background = s.color;
    item.appendChild(sw);
    const txt = document.createElement('span');
    txt.textContent = s.label;
    item.appendChild(txt);
    box.appendChild(item);
  }
}

// キリのいい数値を計算（部門別売買動向用、千円単位）
// 折れ線最大値 < 縦軸最大値 を保証
// 25兆円以上の値にも対応
function calcNiceTicks(minV, maxV, targetCount = 5){
  const range = maxV - minV;
  if(range === 0) return [minV, minV];

  // 億円単位での範囲
  const rangeOku = range / 1e5;

  // キリのいい間隔を計算（億円単位）
  // 50000億=5兆、100000億=10兆、200000億=20兆、500000億=50兆
  const niceIntervals = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000];
  const rawInterval = rangeOku / targetCount;

  let bestInterval = niceIntervals[0];
  for(const ni of niceIntervals){
    if(ni >= rawInterval){
      bestInterval = ni;
      break;
    }
    bestInterval = ni;
  }

  // 千円単位に戻す
  const interval = bestInterval * 1e5;

  // 開始値をキリのいい数値に（minVを含むか下回る）
  const startTick = Math.floor(minV / interval) * interval;
  // 終了値をキリのいい数値に（maxVを必ず超える）
  const endTick = Math.ceil(maxV / interval) * interval;

  const ticks = [];
  for(let t = startTick; t <= endTick; t += interval){
    ticks.push(t);
    if(ticks.length > 10) break;
  }

  // 最後のtickがmaxVを超えていることを保証
  if(ticks.length > 0 && ticks[ticks.length - 1] < maxV){
    ticks.push(ticks[ticks.length - 1] + interval);
  }

  return ticks;
}

// 株価指数用のキリのいい数値を計算
// 折れ線最大値 < 縦軸最大値 を保証
function calcIdxNiceTicks(minV, maxV, targetCount = 5){
  const range = maxV - minV;
  if(range === 0) return [minV, minV];

  // キリのいい間隔を計算
  const niceIntervals = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];
  const rawInterval = range / targetCount;

  let bestInterval = niceIntervals[0];
  for(const ni of niceIntervals){
    if(ni >= rawInterval){
      bestInterval = ni;
      break;
    }
    bestInterval = ni;
  }

  // 開始値をキリのいい数値に（minVを含むか下回る）
  const startTick = Math.floor(minV / bestInterval) * bestInterval;
  // 終了値をキリのいい数値に（maxVを必ず超える）
  const endTick = Math.ceil(maxV / bestInterval) * bestInterval;

  const ticks = [];
  for(let t = startTick; t <= endTick; t += bestInterval){
    ticks.push(t);
    if(ticks.length > 10) break;
  }

  // 最後のtickがmaxVを超えていることを保証
  if(ticks.length > 0 && ticks[ticks.length - 1] < maxV){
    ticks.push(ticks[ticks.length - 1] + bestInterval);
  }

  return ticks;
}

function drawChartGeneric(ctx, canvas, data, visibleDates, visibleAbsIndices, isTseChart = false){
  const w=canvas.width, h=canvas.height;
  const pad={t:14,b:28,l:12,r:90};
  const chartW=w-pad.l-pad.r;
  const chartH=h-pad.t-pad.b;

  ctx.clearRect(0,0,w,h);

  ctx.font = "12px -apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif";

  if(!data || !data.series || data.series.length===0 || !data.dates || data.dates.length===0){
    ctx.fillStyle='#6b7280';
    ctx.textAlign='center';
    ctx.fillText("データを選択してください", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  // 累積データのオフセットを計算（表示範囲の最初の有効な値を0とする）
  const seriesOffsets = data.series.map(s => {
    if(!s.isCumulative) return 0;
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx != null && s.values[absIdx] != null && !Number.isNaN(s.values[absIdx])){
        return s.values[absIdx];
      }
    }
    return 0;
  });

  // 値取得関数（累積の場合はオフセット調整）
  const getValue = (s, absIdx, seriesIdx) => {
    const v = s.values[absIdx];
    if(v == null || Number.isNaN(v)) return null;
    if(s.isCumulative) return v - seriesOffsets[seriesIdx];
    return v;
  };

  let minV=Infinity, maxV=-Infinity;
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx==null) continue;
      const v = getValue(s, absIdx, si);
      if(v==null) continue;
      minV=Math.min(minV,v); maxV=Math.max(maxV,v);
    }
  }
  if(minV===Infinity){
    ctx.fillStyle='#6b7280'; ctx.textAlign='center'; ctx.fillText("表示範囲にデータがありません", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  const range=(maxV-minV)||1;

  // 両チャートともキリのいい数値で範囲を設定
  let plotMinV, plotMaxV;
  let ticks = [];
  if(isTseChart){
    ticks = calcNiceTicks(minV, maxV, 4);
  } else {
    ticks = calcIdxNiceTicks(minV, maxV, 4);
  }

  if(ticks.length >= 2){
    plotMinV = ticks[0];
    plotMaxV = ticks[ticks.length - 1];
    const tickRange = plotMaxV - plotMinV;
    // 折れ線が確実にチャート内に収まるようにパディングを追加
    plotMinV -= tickRange * 0.05;
    plotMaxV += tickRange * 0.05;
  } else {
    plotMinV = minV - range*0.1;
    plotMaxV = maxV + range*0.1;
  }

  const scaleY=chartH/(plotMaxV-plotMinV);
  const getX=(i)=>pad.l+(i+0.5)*(chartW/visibleDates.length);
  const getY=(val)=>pad.t+chartH-(val-plotMinV)*scaleY;

  // グリッド線と補助線を描画
  if(ticks.length >= 2){
    const tickInterval = ticks[1] - ticks[0];

    // メイングリッド線（5本）と補助線
    for(let i = 0; i < ticks.length; i++){
      const t = ticks[i];
      const y = getY(t);

      // メイングリッド線
      ctx.strokeStyle='#e0e0e0';
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();

      // 価格ラベル
      ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
      const formattedVal = isTseChart ? formatTseAxisValue(t) : formatIdxAxisValue(t);
      ctx.fillText(formattedVal, w-pad.r+6, y+4);

      // 補助線（次のティックとの間に1本）
      if(i < ticks.length - 1){
        const midY = getY(t + tickInterval / 2);
        ctx.strokeStyle='#f0f0f0';
        ctx.lineWidth=1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(pad.l, midY); ctx.lineTo(w-pad.r, midY); ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  } else {
    // フォールバック
    const gridSteps=4;
    for(let i=0;i<=gridSteps;i++){
      const y=pad.t+(chartH*i/gridSteps);
      const v=plotMaxV-(plotMaxV-plotMinV)*(i/gridSteps);
      ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
      ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
      const formattedVal = isTseChart ? formatTseAxisValue(v) : formatIdxAxisValue(v);
      ctx.fillText(formattedVal, w-pad.r+6, y+4);
    }
  }

  // 日付ラインと日付ラベルの表示
  visibleDates.forEach((d,i)=>{
    if(d && i % Math.ceil(visibleDates.length/6)===0){
      const x = getX(i);

      // 縦線を描画（showDateLineがオンの場合のみ）
      if(showDateLine){
        ctx.strokeStyle='#e5e7eb';
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(x, pad.t);
        ctx.lineTo(x, h-pad.b);
        ctx.stroke();
      }

      // 日付ラベルは常に表示（showFullDateがfalseなら月表示のみ）
      let displayDate = d;
      if(!showFullDate && d){
        // YYYY-MM-DD形式からYYYY-MMに変換
        const parts = d.split('-');
        if(parts.length >= 2){
          displayDate = parts[0] + '-' + parts[1];
        }
      }
      ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--axisDark').trim() || '#6b7280';
      ctx.textAlign='center';
      ctx.fillText(displayDate, x, h-6);
    }
  });

  // ツールチップ用にオフセット情報も保存
  canvas.pointPositions = visibleDates.map((d,i)=>({
    x:getX(i),
    w:chartW/visibleDates.length,
    absIndex:visibleAbsIndices[i],
    date:d
  }));
  canvas.seriesOffsets = seriesOffsets;

  // 各系列を描画
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    const color = s.color || '#000000';
    const lineWidth = s.width || 2;

    // 有効なデータポイントを収集
    const validPoints = [];
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx == null) continue;
      const v = getValue(s, absIdx, si);
      if(v == null || !Number.isFinite(v)) continue;
      const x = getX(i);
      const y = getY(v);
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      validPoints.push({x, y});
    }

    // 線を描画（有効なポイント間を連続して繋ぐ）
    if(validPoints.length >= 2){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(validPoints[0].x, validPoints[0].y);
      for(let i=1; i<validPoints.length; i++){
        ctx.lineTo(validPoints[i].x, validPoints[i].y);
      }
      ctx.stroke();
      ctx.restore();
    } else if(validPoints.length === 1){
      // 1点のみの場合は小さな円で表示
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(validPoints[0].x, validPoints[0].y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function formatAxisValue(v){
  const absV = Math.abs(v);
  if(absV >= 1e12){
    return (v / 1e12).toFixed(1) + "兆";
  } else if(absV >= 1e8){
    return (v / 1e8).toFixed(1) + "億";
  } else if(absV >= 1e4){
    return (v / 1e4).toFixed(0) + "万";
  } else {
    return v.toFixed(0);
  }
}

// 株価指数用：日経平均等の表示を改良（5万5000形式）
function formatIdxAxisValue(v){
  const absV = Math.abs(v);
  const sign = v < 0 ? '-' : '';

  if(absV >= 10000){
    // 1万以上：○万○○○○形式
    const man = Math.floor(absV / 10000);
    const remainder = Math.round(absV % 10000);
    if(remainder === 0){
      return sign + man + "万";
    }
    return sign + man + "万" + remainder;
  } else if(absV >= 1000){
    // 1000以上：そのまま表示
    return Math.round(v).toLocaleString();
  } else {
    return v.toFixed(0);
  }
}

// 部門別売買動向用：千円単位→億円単位で表示
// 1億円 = 100,000千円（1e5）
// 1兆円 = 100,000,000千円（1e8）
function formatTseAxisValue(v){
  // vは千円単位
  const okuVal = v / 1e5; // 億円に変換
  const absOku = Math.abs(okuVal);

  if(absOku >= 10000){
    // 1兆以上：○兆○○○○億円
    const cho = Math.floor(okuVal / 10000);
    const oku = Math.abs(Math.round(okuVal % 10000));
    if(oku === 0){
      return cho + "兆円";
    }
    return cho + "兆" + oku + "億円";
  } else {
    // 1兆未満：○○億円
    return Math.round(okuVal) + "億円";
  }
}

function resizeCanvas(canvas){
  const rect=canvas.getBoundingClientRect();
  canvas.width=Math.floor(rect.width);
  canvas.height=Math.floor(rect.height);
}

/* ========= tooltip ========= */
function fmt(n){
  return (n!==null && n!==undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined,{maximumFractionDigits:2})
    : '-';
}
function showTooltipForCanvas(e, canvas, data){
  const pps = canvas.pointPositions;
  if(!pps || !data) return;

  const rect=canvas.getBoundingClientRect();
  const mouseX=e.clientX-rect.left;

  const p = pps.find(pp => mouseX >= pp.x - pp.w/2 && mouseX <= pp.x + pp.w/2);
  if(!p){
    tooltip.style.display='none';
    return;
  }
  const absIdx = p.absIndex;
  const date = p.date || (absIdx!=null ? data.dates[absIdx] : "") || "";
  const offsets = canvas.seriesOffsets || [];
  let html = `<strong>${date}</strong><br>`;
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    let val = (absIdx!=null ? s.values[absIdx] : null);
    // 累積データの場合はオフセット調整
    if(val != null && s.isCumulative && offsets[si] != null){
      val = val - offsets[si];
    }
    html += `<span style="color:${s.color}; font-weight:700;">${s.label}</span>: ${fmt(val)}<br>`;
  }
  tooltip.innerHTML = html;
  tooltip.style.display='block';

  let tx=e.clientX+14, ty=e.clientY+14;
  if(tx+260>window.innerWidth) tx-=280;
  tooltip.style.left=tx+'px';
  tooltip.style.top=ty+'px';
}

/* ========= interactions (shared) ========= */
function getBaseDates(){
  // 両チャートで統一された時系列を返す（週次データ優先）
  return tseDates.length > 0 ? tseDates : idxDates;
}

function onWheelZoom(e){
  e.preventDefault();
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;

  const shrink = (e.deltaY < 0);
  displayCount += (shrink ? -1 : +1);
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, baseDates.length));

  offsetX = 0;

  syncCountControls();
  updateTopChips();
  redrawAll();
}
function onMouseDown(e, canvas){
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;
  isDragging = true;
  dragCanvas = canvas;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}
function onMouseMove(e){
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;

  if(isDragging){
    const canvas = dragCanvas || idxCanvas;
    const rect = canvas.getBoundingClientRect();
    const usableW = Math.max(1, rect.width - 120);
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, usableW / displayCount);
    const moveBars = diffX / ppc;

    const n = baseDates.length;
    const maxOffset = Math.max(0, n - displayCount);

    let newOffset = dragStartOffset + moveBars;
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = Math.round(newOffset);

    updateTopChips();
    redrawAll();
  }
}
function onMouseUp(){
  isDragging = false;
  dragCanvas = null;
  document.body.style.cursor = 'default';
}
function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display='none';
}

/* ========= redraw ========= */
function rebuildData(){
  // 基準となる時系列は週次データ（tseDates）を使用
  // 両チャートで同じ時系列を使うことで、折れ線グラフの横幅と時系列が完全に一致する
  const baseDates = tseDates.length > 0 ? tseDates : idxDates;

  // 指数データ: tseDatesにマッピング（日次→週次）
  idxData = buildIdxSeries(idxRows, idxKey, baseDates, idxDates);
  idxData.dateIndex = buildDateIndex(baseDates);

  // 部門別データ
  tseData = buildTseSeries(tseRows, tseKeys, tseColors, baseDates, tseVisible);
  tseData.dateIndex = buildDateIndex(baseDates);

  renderLegend("idxLegend", idxData);
  renderLegend("tseLegend", tseData);

  // UIの状態を更新（差引累計がある場合は他を無効化）
  updateTseSelectionUI();
}

function redrawAll(){
  rebuildData(); // 累積計算のために毎回再構築

  // 両チャートで同じ時系列（tseDates）を使用
  // これにより折れ線グラフの横幅と時系列の線が完全に一致する
  const baseDates = tseDates.length > 0 ? tseDates : idxDates;

  // 共通の表示範囲を計算
  const commonWindow = getVisibleWindowForDates(baseDates);

  // 両チャートで同じvisibleDates, visibleAbsIndicesを使用
  drawChartGeneric(idxCtx, idxCanvas, idxData, commonWindow.visibleDates, commonWindow.visibleAbsIndices, false);
  drawChartGeneric(tseCtx, tseCanvas, tseData, commonWindow.visibleDates, commonWindow.visibleAbsIndices, true);
}

/* ========= select UI ========= */
function updateTseSelectionUI(){
  // 差引累計が1つでも選択・表示されているかチェック
  const hasCumulative = tseKeys.some((k, i) => k && k.endsWith("_差引累計") && tseVisible[i]);

  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    const sel = document.getElementById(`tseSel${i+1}`);
    const colorPicker = document.getElementById(`tseColor${i+1}`);
    const checkbox = document.getElementById(`tseCheck${i+1}`);
    const selDiv = sel ? sel.closest('.sel') : null;

    if(!sel || !checkbox || !selDiv) continue;

    const k = tseKeys[i];
    const isCumulative = k && k.endsWith("_差引累計");

    // チェックボックスの状態を更新
    checkbox.checked = tseVisible[i];

    // 差引累計がある場合、差引累計以外は無効化表示
    if(hasCumulative && k && !isCumulative){
      selDiv.classList.add('disabled');
    } else {
      selDiv.classList.remove('disabled');
    }
  }
}

function fillIdxSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "— 選択してください —";
  selectEl.appendChild(optEmpty);
  for(const n of names){
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = n;
    selectEl.appendChild(opt);
  }
  selectEl.value = current || "";
}

// 表示名からvalue（キー名）を抽出する関数
function extractKeyFromDisplayName(displayName){
  // ├─、└─、　├─、　└─などのプレフィックスを除去
  return displayName.replace(/^[├└　 ─]+/, '').trim();
}

function fillTseSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "— 選択 —";
  selectEl.appendChild(optEmpty);

  let currentOptGroup = null;

  for(const n of names){
    const trimmed = n.trim();

    // セパレータ行（ー差引累計ー、ー個別項目ー）はoptgroupとして扱う
    if(trimmed.startsWith("ー") && trimmed.endsWith("ー")){
      currentOptGroup = document.createElement("optgroup");
      currentOptGroup.label = trimmed;
      selectEl.appendChild(currentOptGroup);
      continue;
    }

    const opt = document.createElement("option");
    const keyName = extractKeyFromDisplayName(n);
    opt.value = keyName;
    opt.textContent = n; // プレフィックス付きの表示名
    opt.dataset.fullName = n; // 元のプレフィックス付き名前を保存
    opt.dataset.shortName = keyName; // プレフィックスなしの名前を保存

    if(currentOptGroup){
      currentOptGroup.appendChild(opt);
    } else {
      selectEl.appendChild(opt);
    }
  }

  selectEl.value = current || "";
  // 選択後の表示をプレフィックスなしに更新
  updateSelectDisplay(selectEl);
}

// 選択されたオプションの表示をプレフィックスなしに変更する
function updateSelectDisplay(selectEl){
  const selectedOpt = selectEl.options[selectEl.selectedIndex];
  if(selectedOpt && selectedOpt.dataset.shortName){
    selectedOpt.textContent = selectedOpt.dataset.shortName;
  }
}

// プルダウンを開くときに全オプションの表示をプレフィックス付きに戻す
function restoreSelectDisplay(selectEl){
  for(const opt of selectEl.options){
    if(opt.dataset.fullName){
      opt.textContent = opt.dataset.fullName;
    }
  }
}

function bindSelects(){
  // 指数セレクト（1つのみ）
  const idxSel = document.getElementById("idxSel1");
  fillIdxSelect(idxSel, idxAvail, idxKey);
  idxSel.addEventListener("change", ()=>{
    idxKey = idxSel.value || "";
    try{ localStorage.setItem("idxKey_v4", idxKey); }catch(e){}
    redrawAll();
  });

  // 部門別セレクト（8つ）
  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    const sel = document.getElementById(`tseSel${i+1}`);
    const colorPicker = document.getElementById(`tseColor${i+1}`);
    const checkbox = document.getElementById(`tseCheck${i+1}`);

    fillTseSelect(sel, tseAvail, tseKeys[i]);
    colorPicker.value = tseColors[i];
    checkbox.checked = tseVisible[i];

    // プルダウンを開くときにプレフィックス付きの表示に戻す
    sel.addEventListener("focus", ()=>{
      restoreSelectDisplay(sel);
    });

    // プルダウンを閉じるときにプレフィックスなしの表示に変更
    sel.addEventListener("blur", ()=>{
      updateSelectDisplay(sel);
    });

    sel.addEventListener("change", ()=>{
      tseKeys[i] = sel.value || "";
      // 何かを選択したら表示をONにする
      if(tseKeys[i]) tseVisible[i] = true;
      try{ localStorage.setItem("tseKeys_v3", JSON.stringify(tseKeys)); }catch(e){}
      try{ localStorage.setItem("tseVisible_v2", JSON.stringify(tseVisible)); }catch(e){}
      // 選択後の表示をプレフィックスなしに更新
      updateSelectDisplay(sel);
      redrawAll();
    });

    colorPicker.addEventListener("input", ()=>{
      tseColors[i] = colorPicker.value;
      try{ localStorage.setItem("tseColors_v2", JSON.stringify(tseColors)); }catch(e){}
      redrawAll();
    });

    checkbox.addEventListener("change", ()=>{
      tseVisible[i] = checkbox.checked;
      try{ localStorage.setItem("tseVisible_v2", JSON.stringify(tseVisible)); }catch(e){}
      redrawAll();
    });
  }
}

/* ========= main load ========= */
async function autoLoad(){
  const statusEl = document.getElementById("status");

  // 指数データ
  idxRows = [];
  try{
    statusEl.textContent = "PtoCSV_long.csv 読み込み中…";
    const txt1 = await fetchTextAutoEncoding("./PtoCSV_long.csv");
    idxRows = parsePtoCsvToLong(txt1);
  }catch(e){
    console.warn(e);
    statusEl.textContent = `PtoCSV_long.csv 読込エラー: ${e.message}`;
  }

  // 部門別データ
  tseRows = [];
  try{
    statusEl.textContent += " / TSEPrime.csv 読み込み中…";
    const txt2 = await fetchTextAutoEncoding("./data/TSEPrime.csv");
    tseRows = parseTsePrimeToLong(txt2);
  }catch(e){
    console.warn(e);
    statusEl.textContent += ` / TSEPrime 読込エラー: ${e.message}`;
  }

  // プルダウン用リスト
  const idxNamesFromData = uniqSorted(idxRows.map(r => r.name));
  const tseNamesFromData = uniqSorted(tseRows.map(r => r.name));

  let idxList = null;
  let tseList = null;
  try{ idxList = await loadNameList("./list.csv"); }catch(e){ console.warn(e); }
  try{ tseList = await loadNameList("./bumonlist.csv"); }catch(e){ console.warn(e); }

  idxAvail = (idxList ? idxList.filter(n => idxNamesFromData.includes(n)) : idxNamesFromData);
  if(idxAvail.length === 0) idxAvail = idxNamesFromData;

  // 部門別リストのフィルタリング（表示順リストを尊重）
  if(tseList){
    tseAvail = tseList.filter(n => {
      const trimmed = n.trim();
      // セパレータ行は常に含める
      if(trimmed.startsWith("ー") && trimmed.endsWith("ー")) return true;
      // キー名を抽出
      const keyName = extractKeyFromDisplayName(n);
      // 合成項目（金融_差引累計、法人_差引累計）は常に含める
      if(COMPOSITE_FIELDS.hasOwnProperty(keyName)) return true;
      // 差引累計項目の場合、ベースとなる差引がデータに存在するか確認
      if(keyName.endsWith("_差引累計")){
        const baseKey = keyName.replace("_差引累計", "_差引");
        return tseNamesFromData.includes(baseKey);
      }
      // 通常の項目はデータに存在するか確認
      return tseNamesFromData.includes(keyName);
    });
  } else {
    tseAvail = tseNamesFromData;
  }
  if(tseAvail.length === 0) tseAvail = tseNamesFromData;

  // 日付軸
  idxDates = buildDateList(idxRows);
  tseDates = buildDateList(tseRows);
  globalDates = buildGlobalDates(idxRows, tseRows);

  // restore selections
  try{
    const raw = localStorage.getItem("idxKey_v4");
    if(raw && idxAvail.includes(raw)){
      idxKey = raw;
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseKeys_v3");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseKeys = new Array(TSE_SELECTION_COUNT).fill("").map((_, i)=> arr[i] || "");
      }
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseColors_v2");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseColors = new Array(TSE_SELECTION_COUNT).fill("").map((_, i)=> arr[i] || DEFAULT_COLORS[i]);
      }
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseVisible_v2");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseVisible = new Array(TSE_SELECTION_COUNT).fill(true).map((_, i)=> arr[i] !== false);
      }
    }
  }catch(e){}

  // デフォルト値設定
  // 株価指数のデフォルト: TOPIX終値
  if(!idxKey){
    if(idxAvail.includes("TOPIX終値")){
      idxKey = "TOPIX終値";
    } else if(idxAvail[0]){
      idxKey = idxAvail[0];
    }
  }

  // 部門別のデフォルト：自己計、個人、海外投資家、投資信託、金融、法人の差引累計
  const defaultTseKeys = [
    "自己計_差引累計",
    "個人_差引累計",
    "海外投資家_差引累計",
    "投資信託_差引累計",
    "金融_差引累計",
    "法人_差引累計",
    "",
    ""
  ];
  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    if(!tseKeys[i] && defaultTseKeys[i]) {
      const key = defaultTseKeys[i];
      // 合成項目（金融_差引累計、法人_差引累計）の場合は直接設定
      if(COMPOSITE_FIELDS.hasOwnProperty(key)){
        tseKeys[i] = key;
      } else {
        // 累計の場合、ベースとなる差引が存在するかチェック
        const baseKey = key.replace("_差引累計", "_差引");
        const tseNamesFromData = uniqSorted(tseRows.map(r => r.name));
        if(tseNamesFromData.includes(baseKey)){
          tseKeys[i] = key;
        }
      }
    }
  }

  const baseDatesLoaded = tseDates.length > 0 ? tseDates : globalDates;
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, baseDatesLoaded.length || displayCount));
  offsetX = 0;
  syncCountControls();
  updateTopChips();

  bindSelects();
  redrawAll();

  statusEl.textContent =
    `ロード完了: 日付 ${globalDates.length.toLocaleString()} / 指数行 ${idxRows.length.toLocaleString()} / 部門行 ${tseRows.length.toLocaleString()}`;
}

/* ========= init ========= */
function init(){
  idxCanvas = document.getElementById("idxChart");
  tseCanvas = document.getElementById("tseChart");
  idxCtx = idxCanvas.getContext("2d");
  tseCtx = tseCanvas.getContext("2d");
  tooltip = document.getElementById("tooltip");

  bindControls();
  const doResize = ()=>{
    resizeCanvas(idxCanvas);
    resizeCanvas(tseCanvas);
    redrawAll();
  };
  window.addEventListener("resize", doResize);
  doResize();

  for(const c of [idxCanvas, tseCanvas]){
    c.addEventListener("wheel", onWheelZoom, {passive:false});
    c.addEventListener("mousedown", (e)=>onMouseDown(e, c));
    c.addEventListener("mousemove", (e)=>{
      onMouseMove(e);
      if(!isDragging){
        const data = (c === idxCanvas ? idxData : tseData);
        showTooltipForCanvas(e, c, data);
      }
    });
    c.addEventListener("mouseup", onMouseUp);
    c.addEventListener("mouseleave", onMouseLeave);
  }
  window.addEventListener("mouseup", onMouseUp);

  // 株価指数プルダウンの表示/非表示トグル
  const idxToggleBtn = document.getElementById("idxToggleBtn");
  const idxSelContainer = document.getElementById("idxSelContainer");
  idxToggleBtn.addEventListener("click", ()=>{
    const isHidden = idxSelContainer.classList.toggle("hidden");
    idxToggleBtn.textContent = isHidden ? "＋" : "－";
  });

  // 部門別プルダウンの表示/非表示トグル
  const tseToggleBtn = document.getElementById("tseToggleBtn");
  const tseSelContainer = document.getElementById("tseSelContainer");
  tseToggleBtn.addEventListener("click", ()=>{
    const isHidden = tseSelContainer.classList.toggle("hidden");
    tseToggleBtn.textContent = isHidden ? "＋" : "－";
  });

  // 説明モーダル
  const helpBtn = document.getElementById("helpBtn");
  const helpModal = document.getElementById("helpModal");
  const modalClose = document.getElementById("modalClose");

  helpBtn.addEventListener("click", ()=>{
    helpModal.classList.add("show");
  });
  modalClose.addEventListener("click", ()=>{
    helpModal.classList.remove("show");
  });
  helpModal.addEventListener("click", (e)=>{
    if(e.target === helpModal){
      helpModal.classList.remove("show");
    }
  });

  autoLoad().catch(err=>{
    console.error(err);
    document.getElementById("status").textContent = `エラー: ${err.message}`;
  });
}
window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
