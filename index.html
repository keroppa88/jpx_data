<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TSEPrime 可視化</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 16px; }
    .controls { display: grid; grid-template-columns: repeat(5, minmax(180px, 1fr)); gap: 10px; margin-bottom: 12px; }
    .control { display: grid; gap: 6px; }
    label { font-size: 12px; color: #333; }
    select { padding: 6px; font-size: 13px; }
    #chart { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; }
    .swatch { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }
    .note { color:#666; font-size:12px; margin-top:8px; }
    .tooltip {
      position: fixed; pointer-events: none; background: rgba(255,255,255,0.96);
      border: 1px solid #ccc; border-radius: 6px; padding: 8px 10px; font-size: 12px;
      box-shadow: 0 3px 12px rgba(0,0,0,0.12); display: none; max-width: 360px;
      white-space: nowrap;
    }
    .axis text { font-size: 11px; }
    .grid line { stroke: #eee; }
  </style>
</head>
<body>
  <h2 style="margin: 0 0 10px 0;">TSEPrime（億円表示・最大10系列）</h2>

  <div class="controls" id="controls"></div>

  <div id="chart"></div>
  <div class="legend" id="legend"></div>
  <div class="note">
    数値はCSV上「千円」想定で、表示は「億円」（千円 ÷ 100,000）に変換しています。横軸は「公表日」です。
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // -----------------------------
    // 日本語表示（対応表）
    // -----------------------------
    const JP = new Map(Object.entries({
      PubDate: "公表日",
      StDate: "開始日",
      EnDate: "終了日",
      Section: "市場名",
      PropSell: "自己計_売",
      PropBuy: "自己計_買",
      PropTot: "自己計_合計",
      PropBal: "自己計_差引",
      BrkSell: "委託計_売",
      BrkBuy: "委託計_買",
      BrkTot: "委託計_合計",
      BrkBal: "委託計_差引",
      TotSell: "総計_売",
      TotBuy: "総計_買",
      TotTot: "総計_合計",
      TotBal: "総計_差引",
      IndSell: "個人_売",
      IndBuy: "個人_買",
      IndTot: "個人_合計",
      IndBal: "個人_差引",
      FrgnSell: "海外投資家_売",
      FrgnBuy: "海外投資家_買",
      FrgnTot: "海外投資家_合計",
      FrgnBal: "海外投資家_差引",
      SecCoSell: "証券会社_売",
      SecCoBuy: "証券会社_買",
      SecCoTot: "証券会社_合計",
      SecCoBal: "証券会社_差引",
      InvTrSell: "投資信託_売",
      InvTrBuy: "投資信託_買",
      InvTrTot: "投資信託_合計",
      InvTrBal: "投資信託_差引",
      BusCoSell: "事業法人_売",
      BusCoBuy: "事業法人_買",
      BusCoTot: "事業法人_合計",
      BusCoBal: "事業法人_差引",
      OthCoSell: "その他法人_売",
      OthCoBuy: "その他法人_買",
      OthCoTot: "その他法人_合計",
      OthCoBal: "その他法人_差引",
      InsCoSell: "生保・損保_売",
      InsCoBuy: "生保・損保_買",
      InsCoTot: "生保・損保_合計",
      InsCoBal: "生保・損保_差引",
      BankSell: "都銀・地銀等_売",
      BankBuy: "都銀・地銀等_買",
      BankTot: "都銀・地銀等_合計",
      BankBal: "都銀・地銀等_差引",
      TrstBnkSell: "信託銀行_売",
      TrstBnkBuy: "信託銀行_買",
      TrstBnkTot: "信託銀行_合計",
      TrstBnkBal: "信託銀行_差引",
      OthFinSell: "その他金融機関_売",
      OthFinBuy: "その他金融機関_買",
      OthFinTot: "その他金融機関_合計",
      OthFinBal: "その他金融機関_差引"
    }));

    const isNumericSeriesKey = (k) => !["PubDate","StDate","EnDate","Section"].includes(k);

    // -----------------------------
    // 日付パース（複数フォーマットに対応）
    // -----------------------------
    const parsers = [
      d3.timeParse("%Y-%m-%d"),
      d3.timeParse("%Y/%m/%d"),
      d3.timeParse("%Y%m%d"),
      d3.timeParse("%Y-%m-%d %H:%M:%S"),
      d3.timeParse("%Y/%m/%d %H:%M:%S"),
    ];
    function parseDateAny(s) {
      if (!s) return null;
      const t = String(s).trim();
      for (const p of parsers) {
        const d = p(t);
        if (d) return d;
      }
      // 最後の手段：Dateに投げる（環境依存）
      const d = new Date(t);
      return isNaN(+d) ? null : d;
    }

    // -----------------------------
    // 表示変換：千円 -> 億円
    // 1億円 = 100,000千円
    // -----------------------------
    const toOkuYen = (thousandYen) => thousandYen / 100000;

    // -----------------------------
    // Chart setup
    // -----------------------------
    const chartEl = document.getElementById("chart");
    const legendEl = document.getElementById("legend");
    const controlsEl = document.getElementById("controls");
    const tooltip = document.getElementById("tooltip");

    const margin = { top: 18, right: 30, bottom: 40, left: 70 };
    const width = 1100;
    const height = 520;

    const svg = d3.select(chartEl).append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("width", "100%")
      .attr("height", "auto");

    const plotW = width - margin.left - margin.right;
    const plotH = height - margin.top - margin.bottom;

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const x = d3.scaleTime().range([0, plotW]);
    const y = d3.scaleLinear().range([plotH, 0]);

    const xAxisG = g.append("g").attr("transform", `translate(0,${plotH})`).attr("class","axis");
    const yAxisG = g.append("g").attr("class","axis");

    const gridG = g.append("g").attr("class","grid");
    const linesG = g.append("g");
    const dotsG = g.append("g");

    g.append("text")
      .attr("x", plotW)
      .attr("y", plotH + 34)
      .attr("text-anchor", "end")
      .attr("font-size", 12)
      .text("公表日");

    g.append("text")
      .attr("x", -10)
      .attr("y", -6)
      .attr("text-anchor", "end")
      .attr("font-size", 12)
      .text("億円");

    // 色（10系列前提だが、念のため余裕）
    const color = (i) => {
      const base = d3.schemeTableau10;
      if (i < base.length) return base[i];
      return d3.interpolateRainbow(i / 20);
    };

    // -----------------------------
    // UI: 10 dropdowns
    // -----------------------------
    const SERIES_SLOTS = 10;
    const selections = Array.from({ length: SERIES_SLOTS }, () => "");

    function renderControls(seriesKeys) {
      controlsEl.innerHTML = "";
      for (let i = 0; i < SERIES_SLOTS; i++) {
        const div = document.createElement("div");
        div.className = "control";

        const label = document.createElement("label");
        label.textContent = `表示項目 ${i + 1}`;
        div.appendChild(label);

        const sel = document.createElement("select");
        sel.dataset.idx = String(i);

        // 空（非表示）
        const optEmpty = document.createElement("option");
        optEmpty.value = "";
        optEmpty.textContent = "（なし）";
        sel.appendChild(optEmpty);

        for (const k of seriesKeys) {
          const opt = document.createElement("option");
          opt.value = k;
          opt.textContent = JP.get(k) ?? k;
          sel.appendChild(opt);
        }

        sel.value = selections[i] || "";
        sel.addEventListener("change", (e) => {
          const idx = +e.target.dataset.idx;
          selections[idx] = e.target.value;
          updateChart();
        });

        div.appendChild(sel);
        controlsEl.appendChild(div);
      }
    }

    // -----------------------------
    // Data load
    // -----------------------------
    let raw = [];
    let seriesKeys = [];

    d3.csv("data/TSEPrime.csv").then(rows => {
      // 必須：PubDate
      raw = rows.map(r => {
        const d = parseDateAny(r.PubDate);
        const out = { ...r, __date: d };
        // 数値列は number に変換（カンマ除去も）
        for (const k of Object.keys(r)) {
          if (!isNumericSeriesKey(k)) continue;
          const v = String(r[k] ?? "").replace(/,/g, "").trim();
          out[k] = v === "" ? null : +v;
        }
        return out;
      }).filter(r => r.__date);

      raw.sort((a,b) => a.__date - b.__date);

      // series keys
      const allKeys = Object.keys(rows[0] ?? {});
      seriesKeys = allKeys.filter(isNumericSeriesKey);

      renderControls(seriesKeys);

      // 初期選択：先頭から最大10
      for (let i = 0; i < SERIES_SLOTS; i++) {
        selections[i] = seriesKeys[i] ?? "";
      }
      // コントロールに反映
      [...controlsEl.querySelectorAll("select")].forEach((s, i) => s.value = selections[i] || "");

      updateChart();
    }).catch(err => {
      chartEl.innerHTML = `<div style="color:#b00;">CSVの読み込みに失敗しました: ${String(err)}</div>`;
      console.error(err);
    });

    // -----------------------------
    // Chart update
    // -----------------------------
    function updateChart() {
      const picked = selections.filter(k => k && seriesKeys.includes(k));
      // 重複排除（同じ項目を複数選ぶと見分けがつかないため）
      const uniq = [];
      for (const k of picked) if (!uniq.includes(k)) uniq.push(k);

      // x domain
      x.domain(d3.extent(raw, d => d.__date));

      // y domain: 選択系列の min/max（億円換算後）
      let yMin = Infinity, yMax = -Infinity;
      for (const k of uniq) {
        for (const row of raw) {
          const v = row[k];
          if (v == null || isNaN(v)) continue;
          const oku = toOkuYen(v);
          if (oku < yMin) yMin = oku;
          if (oku > yMax) yMax = oku;
        }
      }
      if (!isFinite(yMin) || !isFinite(yMax)) { yMin = -1; yMax = 1; }
      // 少し余白
      const pad = (yMax - yMin) * 0.08 || 1;
      y.domain([yMin - pad, yMax + pad]).nice();

      // axes
      const xAxis = d3.axisBottom(x).ticks(10);
      const yAxis = d3.axisLeft(y).ticks(8).tickFormat(d => `${d3.format(",.2f")(d)}`);

      xAxisG.call(xAxis);
      yAxisG.call(yAxis);

      // grid
      gridG.selectAll("*").remove();
      gridG.call(d3.axisLeft(y).ticks(8).tickSize(-plotW).tickFormat(""))
        .selectAll("line");
      gridG.selectAll("path").remove();

      // line generator
      const line = d3.line()
        .defined(d => d.v != null && !isNaN(d.v))
        .x(d => x(d.date))
        .y(d => y(d.oku));

      // build series
      const series = uniq.map((k, i) => {
        const values = raw.map(r => ({
          key: k,
          label: JP.get(k) ?? k,
          date: r.__date,
          v: r[k],
          oku: (r[k] == null || isNaN(r[k])) ? null : toOkuYen(r[k])
        }));
        return { key: k, label: JP.get(k) ?? k, i, values };
      });

      // render lines
      const paths = linesG.selectAll("path").data(series, d => d.key);
      paths.enter().append("path")
        .attr("fill", "none")
        .attr("stroke-width", 2)
        .attr("stroke", d => color(d.i))
        .merge(paths)
        .attr("stroke", d => color(d.i))
        .attr("d", d => line(d.values));
      paths.exit().remove();

      // dots (hover)
      const flat = series.flatMap(s => s.values.filter(v => v.oku != null).map(v => ({...v, si: s.i})));
      const dots = dotsG.selectAll("circle").data(flat, d => `${d.key}_${+d.date}`);
      dots.enter().append("circle")
        .attr("r", 2.6)
        .attr("fill", d => color(d.si))
        .attr("cx", d => x(d.date))
        .attr("cy", d => y(d.oku))
        .on("mouseenter", (evt, d) => {
          tooltip.style.display = "block";
          tooltip.textContent = `${d3.timeFormat("%Y-%m-%d")(d.date)}  ${JP.get(d.key) ?? d.key}: ${d3.format(",.2f")(d.oku)} 億円`;
        })
        .on("mousemove", (evt) => {
          tooltip.style.left = (evt.clientX + 12) + "px";
          tooltip.style.top = (evt.clientY + 12) + "px";
        })
        .on("mouseleave", () => {
          tooltip.style.display = "none";
        })
        .merge(dots)
        .attr("fill", d => color(d.si))
        .attr("cx", d => x(d.date))
        .attr("cy", d => y(d.oku));
      dots.exit().remove();

      // legend
      legendEl.innerHTML = "";
      for (const s of series) {
        const item = document.createElement("div");
        item.className = "legend-item";
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = color(s.i);
        const tx = document.createElement("span");
        tx.textContent = s.label;
        item.appendChild(sw);
        item.appendChild(tx);
        legendEl.appendChild(item);
      }
    }
  </script>
</body>
</html>
