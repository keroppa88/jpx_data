<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>株価指数・部門別売買動向チャート</title>
  <style>
    :root{
      --bg:#f5f5f7;
      --card:#ffffff;
      --text:#1f2328;
      --muted:#6b7280;
      --axisDark:#6b7280;
      --line:#e5e7eb;
      --chip:#f3f4f6;
      --shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    body{
      margin:0; padding:16px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg); color:var(--text);
    }
    .wrap{ width:100%; margin:0 auto; }
    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:14px; box-shadow:var(--shadow);
      padding:14px 16px;
      max-width:1240px;
      margin:0 auto;
    }
    .header{
      display:flex; align-items:baseline; gap:12px; flex-wrap:wrap;
    }
    .header h1{ margin:0; font-size:16px; letter-spacing:0.2px; }
    .sub{ font-size:12px; color:var(--muted); }
    .headerRight{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .rows{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

    .controls{
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .group{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fafafa;
      border-radius:12px;
    }
    .label{ font-weight:700; font-size:12px; color:#374151; }
    input[type="range"]{ width:260px; }
    input[type="number"]{
      width:86px; padding:6px 8px;
      border:1px solid #cfd4dc; border-radius:10px;
      background:#fff; font-size:13px; text-align:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      background:var(--chip);
      border-radius:999px;
      font-size:12px; color:#111827;
      white-space:nowrap;
    }
    .chip .muted{ color:var(--muted); }

    .grid2{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .chartCard{ border:1px solid var(--line); border-radius:12px; background:#fff; overflow:hidden; }
    .chartHead{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background:#fafafa;
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    .chartTitle{ font-weight:700; font-size:13px; color:#111827; margin-right:auto; }

    .legend{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .legend-item{ display:flex; align-items:center; gap:6px; font-size:12px; color:#374151; }
    .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.15); }

    .selRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      width:100%;
    }
    .sel{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:12px;
    }
    .sel .slot{
      width:18px;
      text-align:right;
      font-size:12px;
      color:var(--muted);
      flex:0 0 auto;
    }
    select{
      min-width:240px;
      padding:6px 8px;
      border:1px solid #cfd4dc;
      border-radius:10px;
      background:#fff;
      font-size:13px;
    }

    .canvasBox{ position:relative; background:#fff; }
    canvas{ display:block; width:100%; cursor:crosshair; }
    #idxChart{ height:260px; }
    #tseChart{ height:520px; }

    .tooltip{
      position:fixed;
      background:rgba(255,255,255,0.98);
      border:1px solid #9ca3af; padding:8px 10px; border-radius:10px;
      font-size:12px; pointer-events:none; display:none;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:1000; line-height:1.45; white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <h1>株価指数・部門別売買動向チャート</h1>
        <span class="sub" id="status">読込中…</span>
        <div class="headerRight">
          <span class="chip" id="latestChip"><span class="muted">最新</span> -</span>
          <span class="chip" id="viewChip"><span class="muted">表示範囲</span> -</span>
        </div>
      </div>

      <div class="rows">
        <div class="controls">
          <div class="group">
            <div class="label">表示本数</div>
            <input id="countRange" type="range" min="10" max="700" step="1" value="200">
            <input id="countNum" type="number" min="10" max="700" step="1" value="200">
          </div>
          <div class="group">
            <div class="label">操作</div>
            <span class="chip"><span class="muted">ホイール</span> 拡大/縮小</span>
            <span class="chip"><span class="muted">ドラッグ</span> 横スクロール</span>
          </div>
        </div>

        <div class="grid2">
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">株価指数</div>
              <div class="legend" id="idxLegend"></div>
              <div class="selRow" id="idxSelRow">
                <div class="sel"><select id="idxSel1"></select></div>
              </div>
            </div>
            </div>
            <div class="canvasBox">
              <canvas id="idxChart"></canvas>
            </div>
          </div>

          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">部門別売買動向（差引項目は起点から累積）</div>
              <div class="legend" id="tseLegend"></div>
              <div class="selRow" id="tseSelRow">
                <div class="sel"><div class="slot">1</div><select id="tseSel1"></select></div>
                <div class="sel"><div class="slot">2</div><select id="tseSel2"></select></div>
                <div class="sel"><div class="slot">3</div><select id="tseSel3"></select></div>
                <div class="sel"><div class="slot">4</div><select id="tseSel4"></select></div>
                <div class="sel"><div class="slot">5</div><select id="tseSel5"></select></div>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="tseChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
  </div>

<script>
/* ========= colors ========= */
const COLOR_PALETTE = [
  { hex: "#FF4B00" }, { hex: "#005AFF" }, { hex: "#03AF7A" },
  { hex: "#4DC4FF" }, { hex: "#F6AA00" }, { hex: "#FFF100" },
  { hex: "#000000" }, { hex: "#990099" }, { hex: "#84919E" }
];
const INITIAL_COLORS = ["#FF4B00","#005AFF","#03AF7A","#4DC4FF","#F6AA00","#FFF100"];
const MAX_DISPLAY = 700;

/* ========= TSEPrime: 英語列名 -> 日本語表示名 ========= */
const TSEPRIME_FIELD_MAP = {
  PropSell: "自己計_売",   PropBuy:"自己計_買",   PropTot:"自己計_合計",   PropBal:"自己計_差引",
  BrkSell: "委託計_売",    BrkBuy:"委託計_買",    BrkTot:"委託計_合計",    BrkBal:"委託計_差引",
  TotSell: "総計_売",      TotBuy:"総計_買",      TotTot:"総計_合計",      TotBal:"総計_差引",
  IndSell: "個人_売",      IndBuy:"個人_買",      IndTot:"個人_合計",      IndBal:"個人_差引",
  FrgnSell:"海外投資家_売",FrgnBuy:"海外投資家_買",FrgnTot:"海外投資家_合計",FrgnBal:"海外投資家_差引",
  SecCoSell:"証券会社_売", SecCoBuy:"証券会社_買", SecCoTot:"証券会社_合計", SecCoBal:"証券会社_差引",
  InvTrSell:"投資信託_売", InvTrBuy:"投資信託_買", InvTrTot:"投資信託_合計", InvTrBal:"投資信託_差引",
  BusCoSell:"事業法人_売", BusCoBuy:"事業法人_買", BusCoTot:"事業法人_合計", BusCoBal:"事業法人_差引",
  OthCoSell:"その他法人_売",OthCoBuy:"その他法人_買",OthCoTot:"その他法人_合計",OthCoBal:"その他法人_差引",
  InsCoSell:"生保・損保_売",InsCoBuy:"生保・損保_買",InsCoTot:"生保・損保_合計",InsCoBal:"生保・損保_差引",
  BankSell:"都銀・地銀等_売",BankBuy:"都銀・地銀等_買",BankTot:"都銀・地銀等_合計",BankBal:"都銀・地銀等_差引",
  TrstBnkSell:"信託銀行_売",TrstBnkBuy:"信託銀行_買",TrstBnkTot:"信託銀行_合計",TrstBnkBal:"信託銀行_差引",
  OthFinSell:"その他金融機関_売",OthFinBuy:"その他金融機関_買",OthFinTot:"その他金融機関_合計",OthFinBal:"その他金融機関_差引"
};

/* ========= state ========= */
let idxRows = [];
let tseRows = [];
let idxDates = [];
let tseDates = [];
let globalDates = [];

let displayCount = 200;
let offsetX = 0;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;
let dragCanvas = null;

let idxCanvas, idxCtx, tseCanvas, tseCtx, tooltip;

let idxAvail = [];
let tseAvail = [];

const IDX_SELECTION_COUNT = 1;
const IDX_STORAGE_KEY = "idxKey_v3";
let idxKeys = new Array(IDX_SELECTION_COUNT).fill("");
let tseKeys = ["","","","",""];

let idxData = null;
let tseData = null;

/* ========= helpers ========= */
function cleanHeaderValue(s){
  return String(s ?? "")
    .replace(/^\uFEFF/, "")
    .replace(/^"+|"+$/g, "")
    .trim();
}

function toNum(s){
  if(s==null) return NaN;
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim());
}
function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}
function uniqSorted(arr){
  const set = new Set(arr);
  const out = Array.from(set);
  out.sort((a,b)=>String(a).localeCompare(String(b)));
  return out;
}
function buildDateList(rows){
  const set = new Set();
  for(const r of rows){ if(r && r.date) set.add(r.date); }
  const arr = Array.from(set);
  arr.sort((a,b)=>{
    const ta=new Date(a).getTime(), tb=new Date(b).getTime();
    if(!Number.isNaN(ta) && !Number.isNaN(tb)) return ta-tb;
    return String(a).localeCompare(String(b));
  });
  return arr;
}
function buildGlobalDates(idxRows, tseRows){
  return buildDateList(idxRows.concat(tseRows));
}
function getVisibleWindowForDates(dates){
  const n = dates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const startRaw = n - count - localOffset;
  const endRaw = startRaw + count;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realDates = (start < end) ? dates.slice(start, end) : [];
  const realLen = realDates.length;

  const padN = count - realLen;
  const pads = new Array(Math.max(0,padN)).fill("");

  const visibleDates = pads.concat(realDates);
  const visibleAbsIndices = new Array(Math.max(0,padN)).fill(null).concat(
    Array.from({length: realLen}, (_,i)=> start + i)
  );
  return { visibleDates, visibleAbsIndices };
}
function buildDateIndex(dates){
  const map = new Map();
  dates.forEach((d,i)=>{ map.set(d, i); });
  return map;
}
function mapVisibleDatesToAbsIndices(dateIndex, visibleDates){
  return visibleDates.map(d => (d && dateIndex && dateIndex.has(d) ? dateIndex.get(d) : null));
}
function updateTopChips(){
  const latestEl = document.getElementById("latestChip");
  const viewEl = document.getElementById("viewChip");
  if(!globalDates || globalDates.length===0){
    latestEl.innerHTML = `<span class="muted">最新</span> -`;
    viewEl.innerHTML = `<span class="muted">表示範囲</span> -`;
    return;
  }
  latestEl.innerHTML = `<span class="muted">最新</span> ${globalDates[globalDates.length-1]}`;

  const { visibleDates } = getVisibleWindowForDates(globalDates);
  let startDate=null, endDate=null;
  for(let i=0;i<visibleDates.length;i++){ if(visibleDates[i]){ startDate=visibleDates[i]; break; } }
  for(let i=visibleDates.length-1;i>=0;i--){ if(visibleDates[i]){ endDate=visibleDates[i]; break; } }
  viewEl.innerHTML = `<span class="muted">表示範囲</span> ${startDate&&endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}
function syncCountControls(){
  const r=document.getElementById('countRange');
  const n=document.getElementById('countNum');
  r.max=String(MAX_DISPLAY);
  n.max=String(MAX_DISPLAY);
  r.value=String(displayCount);
  n.value=String(displayCount);
}
function bindControls(){
  const countRange=document.getElementById('countRange');
  const countNum=document.getElementById('countNum');

  const setCount=(v)=>{
    const nn=Number(v);
    if(!Number.isFinite(nn)) return;
    displayCount=Math.max(10, Math.min(Math.round(nn), MAX_DISPLAY, globalDates.length||MAX_DISPLAY));
    offsetX=0;
    countRange.value=String(displayCount);
    countNum.value=String(displayCount);
    updateTopChips();
    redrawAll();
  };

  countRange.addEventListener('input', ()=>setCount(countRange.value));
  countNum.addEventListener('change', ()=>setCount(countNum.value));
}

/* ========= encoding-safe fetch ========= */
async function fetchTextAutoEncoding(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`${url} fetch失敗: ${res.status} ${res.statusText}`);
  const buf = await res.arrayBuffer();

  const tUtf8 = new TextDecoder("utf-8", {fatal:false}).decode(buf);
  // ここは「典型的に含まれるはずの識別子」で雑に判定（十分実用）
  if (tUtf8.includes("PubDate") || tUtf8.includes("公表日") || tUtf8.includes("PropSell") || tUtf8.includes("自己計") || tUtf8.includes("日付")) {
    return tUtf8;
  }
  const tSjis = new TextDecoder("shift-jis", {fatal:false}).decode(buf);
  return tSjis;
}

/* ========= parsers ========= */
function parsePtoCsvToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("PtoCSV_long.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxDate=header.indexOf("日付");
  const idxName=header.indexOf("商品名");
  const idxVal=header.indexOf("数値");
  if(idxDate<0||idxName<0||idxVal<0) throw new Error("PtoCSV_long.csv: 必須列(日付, 商品名, 数値)が見つかりません");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;
    const date=(cols[idxDate]||"").trim();
    const name=(cols[idxName]||"").trim();
    const value=toNum(cols[idxVal]);
    if(!date || !name || Number.isNaN(value)) continue;
    rows.push({date, name, value});
  }
  return rows;
}

function parseTsePrimeToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("TSEPrime.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxPubDate=header.indexOf("PubDate") >= 0 ? header.indexOf("PubDate") : header.indexOf("公表日");
  const idxSection=header.indexOf("Section") >= 0 ? header.indexOf("Section") : header.indexOf("市場名");
  if(idxPubDate<0) throw new Error("TSEPrime.csv: 必須列(PubDate/公表日)が見つかりません");

  const fieldDefs = Object.entries(TSEPRIME_FIELD_MAP)
    .map(([en, jp]) => ({ jp, idx: header.indexOf(en) >= 0 ? header.indexOf(en) : header.indexOf(jp) }))
    .filter(x => x.idx >= 0);

  if(fieldDefs.length===0) throw new Error("TSEPrime.csv: 数値列が見つかりません（Field map 不一致 / 文字化けの可能性）");

  let sectionFilter = null;
  if(idxSection >= 0){
    const hasTsePrime = lines.slice(1).some(line => {
      const cols = parseDelimitedLine(line, delim);
      const section = (cols[idxSection] || "").trim();
      return section === "TSEPrime";
    });
    if(hasTsePrime) sectionFilter = "TSEPrime";
  }

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;

    if(idxSection >= 0 && sectionFilter){
      const section=(cols[idxSection]||"").trim();
      if(section!==sectionFilter) continue;
    }

    const date=(cols[idxPubDate]||"").trim();
    if(!date) continue;

    for(const f of fieldDefs){
      const value=toNum(cols[f.idx]);
      if(Number.isNaN(value)) continue;
      rows.push({date, name: f.jp, value});
    }
  }
  return rows;
}

/* ========= list loaders ========= */
async function loadNameList(filename){
  async function fetchText(decoderName){
    const res = await fetch(filename, {cache:'no-store'});
    if(!res.ok) return null;
    const buf = await res.arrayBuffer();
    const dec = new TextDecoder(decoderName, {fatal:false});
    return dec.decode(buf);
  }
  function parseToNames(text){
    if(!text) return null;
    const lines = text.split(/\r?\n/);
    const out = [];
    for(const raw of lines){
      let line = String(raw||"");
      line = line.replace(/^\uFEFF/, "").trim();
      if(!line || line.startsWith('#')) continue;
      const first = line.split(/\t|,/)[0].replace(/^"+|"+$/g,'').trim();
      if(first) out.push(first);
    }
    const seen = new Set();
    const uniq = [];
    for(const n of out){
      if(seen.has(n)) continue;
      seen.add(n);
      uniq.push(n);
    }
    return uniq.length ? uniq : null;
  }

  const tUtf8 = await fetchText('utf-8');
  const nUtf8 = parseToNames(tUtf8);

  const tSjis = await fetchText('shift-jis');
  const nSjis = parseToNames(tSjis);

  if(!nUtf8 && !nSjis) return null;
  if(nUtf8 && !nSjis) return nUtf8;
  if(!nUtf8 && nSjis) return nSjis;
  return (nSjis.length > nUtf8.length ? nSjis : nUtf8);
}

/* ========= series building ========= */
function buildOneSeries(rows, key, color, dates){
  const map = new Map();
  for(const r of rows){ if(r.name===key) map.set(r.date, r.value); }
  const values = dates.map(d => (map.has(d) ? map.get(d) : null));
  return { label: key, color, width: 2, values };
}

// 差引項目を累積表示する（起点日を0として累積）
function buildCumulativeSeries(rows, key, color, dates){
  const map = new Map();
  for(const r of rows){ if(r.name===key) map.set(r.date, r.value); }

  // 累積計算
  const values = [];
  let cumulative = 0;
  for(const d of dates){
    if(map.has(d)){
      cumulative += map.get(d);
      values.push(cumulative);
    } else {
      values.push(null);
    }
  }
  return { label: key + "（累積）", color, width: 2, values };
}

// 差引項目かどうか判定
function isBalanceField(name){
  return name && name.includes("差引");
}

function buildMultiSeries(rows, keys, dates){
  const series = [];
  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    if(!k) continue;
    series.push(buildOneSeries(rows, k, INITIAL_COLORS[i] || COLOR_PALETTE[i % COLOR_PALETTE.length].hex, dates));
  }
  return { dates, series };
}

// TSE用：差引項目は累積表示
function buildTseSeries(rows, keys, dates){
  const series = [];
  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    if(!k) continue;
    if(isBalanceField(k)){
      series.push(buildCumulativeSeries(rows, k, INITIAL_COLORS[i] || COLOR_PALETTE[i % COLOR_PALETTE.length].hex, dates));
    } else {
      series.push(buildOneSeries(rows, k, INITIAL_COLORS[i] || COLOR_PALETTE[i % COLOR_PALETTE.length].hex, dates));
    }
  }
  return { dates, series };
}

/* ========= draw ========= */
function renderLegend(elId, data){
  const box = document.getElementById(elId);
  if(!box) return;
  box.innerHTML = '';
  if(!data || !data.series || data.series.length===0) return;
  for(const s of data.series){
    const item = document.createElement('div');
    item.className = 'legend-item';
    const sw = document.createElement('span');
    sw.className = 'swatch';
    sw.style.background = s.color;
    item.appendChild(sw);
    const txt = document.createElement('span');
    txt.textContent = s.label;
    item.appendChild(txt);
    box.appendChild(item);
  }
}

function drawChartGeneric(ctx, canvas, data, visibleDates, visibleAbsIndices){
  const w=canvas.width, h=canvas.height;
  const pad={t:14,b:28,l:12,r:74};
  const chartW=w-pad.l-pad.r;
  const chartH=h-pad.t-pad.b;

  ctx.clearRect(0,0,w,h);

  ctx.font = "12px -apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif"; // 念のため固定

  if(!data || !data.series || data.series.length===0 || !data.dates || data.dates.length===0){
    ctx.fillStyle='#6b7280';
    ctx.textAlign='center';
    ctx.fillText("No Data", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  let minV=Infinity, maxV=-Infinity;
  for(const s of data.series){
    for(const absIdx of visibleAbsIndices){
      if(absIdx==null) continue;
      const v=s.values[absIdx];
      if(v==null || Number.isNaN(v)) continue;
      minV=Math.min(minV,v); maxV=Math.max(maxV,v);
    }
  }
  if(minV===Infinity){
    ctx.fillStyle='#6b7280'; ctx.textAlign='center'; ctx.fillText("No Data", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  const range=(maxV-minV)||1;
  minV -= range*0.06;
  maxV += range*0.06;

  const scaleY=chartH/(maxV-minV);
  const getX=(i)=>pad.l+(i+0.5)*(chartW/visibleDates.length);
  const getY=(val)=>pad.t+chartH-(val-minV)*scaleY;

  ctx.strokeStyle='#eef0f3'; ctx.lineWidth=1;
  const gridSteps=5;
  for(let i=0;i<=gridSteps;i++){
    const y=pad.t+(chartH*i/gridSteps);
    const v=maxV-(maxV-minV)*(i/gridSteps);
    ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
    ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
    ctx.fillText(String(Math.round(v)), w-pad.r+6, y+4);
  }

  visibleDates.forEach((d,i)=>{
    if(d && i % Math.ceil(visibleDates.length/6)===0){
      ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--axisDark').trim() || '#6b7280';
      ctx.textAlign='center';
      ctx.fillText(d, getX(i), h-6);
    }
  });

  canvas.pointPositions = visibleDates.map((d,i)=>({
    x:getX(i),
    w:chartW/visibleDates.length,
    absIndex:visibleAbsIndices[i],
    date:d
  }));

  for(const s of data.series){
    ctx.strokeStyle=s.color;
    ctx.lineWidth=s.width;
    ctx.beginPath();
    let moved=false;
    visibleAbsIndices.forEach((absIdx,i)=>{
      if(absIdx==null){ moved=false; return; }
      const v=s.values[absIdx];
      if(v==null || Number.isNaN(v)){ moved=false; return; }
      const x=getX(i), y=getY(v);
      if(!moved){ ctx.moveTo(x,y); moved=true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }
}

function resizeCanvas(canvas){
  const rect=canvas.getBoundingClientRect();
  canvas.width=Math.floor(rect.width);
  canvas.height=Math.floor(rect.height);
}

/* ========= tooltip ========= */
function fmt(n){
  return (n!==null && n!==undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined,{maximumFractionDigits:2})
    : '-';
}
function showTooltipForCanvas(e, canvas, data){
  const pps = canvas.pointPositions;
  if(!pps || !data) return;

  const rect=canvas.getBoundingClientRect();
  const mouseX=e.clientX-rect.left;

  const p = pps.find(pp => mouseX >= pp.x - pp.w/2 && mouseX <= pp.x + pp.w/2);
  if(!p){
    tooltip.style.display='none';
    return;
  }
  const absIdx = p.absIndex;
  const date = p.date || (absIdx!=null ? data.dates[absIdx] : "") || "";
  let html = `<strong>${date}</strong><br>`;
  for(const s of data.series){
    const val = (absIdx!=null ? s.values[absIdx] : null);
    html += `<span style="color:${s.color}; font-weight:700;">${s.label}</span>: ${fmt(val)}<br>`;
  }
  tooltip.innerHTML = html;
  tooltip.style.display='block';

  let tx=e.clientX+14, ty=e.clientY+14;
  if(tx+260>window.innerWidth) tx-=280;
  tooltip.style.left=tx+'px';
  tooltip.style.top=ty+'px';
}

/* ========= interactions (shared) ========= */
function onWheelZoom(e){
  e.preventDefault();
  if(!globalDates || globalDates.length===0) return;

  const shrink = (e.deltaY < 0);
  displayCount += (shrink ? -1 : +1);
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, globalDates.length));

  offsetX = 0;

  syncCountControls();
  updateTopChips();
  redrawAll();
}
function onMouseDown(e, canvas){
  if(!globalDates || globalDates.length===0) return;
  isDragging = true;
  dragCanvas = canvas;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}
function onMouseMove(e){
  if(!globalDates || globalDates.length===0) return;

  if(isDragging){
    const canvas = dragCanvas || idxCanvas;
    const rect = canvas.getBoundingClientRect();
    const usableW = Math.max(1, rect.width - 120);
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, usableW / displayCount);
    const moveBars = diffX / ppc;

    const n = globalDates.length;
    const maxOffset = Math.max(0, n - displayCount);

    let newOffset = dragStartOffset + moveBars;
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = Math.round(newOffset);

    updateTopChips();
    redrawAll();
  }
}
function onMouseUp(){
  isDragging = false;
  dragCanvas = null;
  document.body.style.cursor = 'default';
}
function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display='none';
}

/* ========= redraw ========= */
function rebuildData(){
  idxData = buildMultiSeries(idxRows, idxKeys, idxDates);
  idxData.dateIndex = buildDateIndex(idxDates);

  // TSEデータは差引項目を累積表示
  tseData = buildTseSeries(tseRows, tseKeys, tseDates);
  tseData.dateIndex = buildDateIndex(tseDates);

  renderLegend("idxLegend", idxData);
  renderLegend("tseLegend", tseData);
}
function redrawAll(){
  const globalWindow = getVisibleWindowForDates(globalDates);
  const resolveWindow = (data, dates) => {
    const absIndices = mapVisibleDatesToAbsIndices(data && data.dateIndex, globalWindow.visibleDates);
    const hasAny = absIndices.some((idx) => idx != null);
    if (hasAny) return { window: globalWindow, absIndices };
    const localWindow = getVisibleWindowForDates(dates);
    return { window: localWindow, absIndices: mapVisibleDatesToAbsIndices(data && data.dateIndex, localWindow.visibleDates) };
  };

  const idxWindow = resolveWindow(idxData, idxDates);
  const tseWindow = resolveWindow(tseData, tseDates);

  drawChartGeneric(idxCtx, idxCanvas, idxData, idxWindow.window.visibleDates, idxWindow.absIndices);
  drawChartGeneric(tseCtx, tseCanvas, tseData, tseWindow.window.visibleDates, tseWindow.absIndices);
}

/* ========= select UI ========= */
function fillSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "—";
  selectEl.appendChild(optEmpty);
  for(const n of names){
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = n;
    selectEl.appendChild(opt);
  }
  selectEl.value = current || "";
}
function bindSelects(){
  // 指数選択（1つのみ）
  const idxEl = document.getElementById("idxSel1");
  fillSelect(idxEl, idxAvail, idxKeys[0]);
  idxEl.addEventListener("change", ()=>{
    idxKeys[0] = idxEl.value || "";
    try{ localStorage.setItem(IDX_STORAGE_KEY, idxKeys[0]); }catch(e){}
    rebuildData(); redrawAll();
  });

  // 部門別選択（5つ）
  for(let i=0;i<5;i++){
    const el = document.getElementById(`tseSel${i+1}`);
    fillSelect(el, tseAvail, tseKeys[i]);
    el.addEventListener("change", ()=>{
      tseKeys[i] = el.value || "";
      try{ localStorage.setItem("tseKeys_v1", JSON.stringify(tseKeys)); }catch(e){}
      rebuildData(); redrawAll();
    });
  }
}

/* ========= main load ========= */
async function autoLoad(){
  const statusEl = document.getElementById("status");

  // 2) 指数データ
  idxRows = [];
  try{
    statusEl.textContent = "PtoCSV_long.csv 読み込み中…";
    const txt1 = await fetchTextAutoEncoding("./PtoCSV_long.csv");
    idxRows = parsePtoCsvToLong(txt1);
  }catch(e){
    console.warn(e);
    statusEl.textContent = `PtoCSV_long.csv 読込エラー: ${e.message}`;
  }

  // 3) 部門別データ
  tseRows = [];
  try{
    statusEl.textContent += " / TSEPrime.csv 読み込み中…";
    const txt2 = await fetchTextAutoEncoding("./data/TSEPrime.csv");
    tseRows = parseTsePrimeToLong(txt2);
  }catch(e){
    console.warn(e);
    statusEl.textContent += ` / TSEPrime 読込エラー: ${e.message}`;
  }

  // 4) プルダウン用リスト
  const idxNamesFromData = uniqSorted(idxRows.map(r => r.name));
  const tseNamesFromData = uniqSorted(tseRows.map(r => r.name));

  let idxList = null;
  let tseList = null;
  try{ idxList = await loadNameList("./list.csv"); }catch(e){ console.warn(e); }
  try{ tseList = await loadNameList("./bumonlist.csv"); }catch(e){ console.warn(e); }

  idxAvail = (idxList ? idxList.filter(n => idxNamesFromData.includes(n)) : idxNamesFromData);
  if(idxAvail.length === 0) idxAvail = idxNamesFromData;

  tseAvail = (tseList ? tseList.filter(n => tseNamesFromData.includes(n)) : tseNamesFromData);
  if(tseAvail.length === 0) tseAvail = tseNamesFromData;

  // 5) 日付軸
  idxDates = buildDateList(idxRows);
  tseDates = buildDateList(tseRows);
  globalDates = buildGlobalDates(idxRows, tseRows);

  // restore last selections
  try{
    const raw = localStorage.getItem(IDX_STORAGE_KEY);
    if(raw && idxAvail.includes(raw)){
      idxKeys[0] = raw;
    }
  }catch(e){}
  try{
    const raw = localStorage.getItem("tseKeys_v1");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr) && arr.length===5){
        tseKeys = arr.map(x => (tseAvail.includes(x) ? x : ""));
      }
    }
  }catch(e){}

  // デフォルト値設定
  if(!idxKeys[0] && idxAvail[0]) idxKeys[0] = idxAvail[0];
  for(let i=0;i<5;i++){
    if(!tseKeys[i] && tseAvail[i]) tseKeys[i] = tseAvail[i];
  }

  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, globalDates.length || displayCount));
  offsetX = 0;
  syncCountControls();
  updateTopChips();

  bindSelects();
  rebuildData();
  redrawAll();

  statusEl.textContent =
    `ロード完了: 日付 ${globalDates.length.toLocaleString()} / 指数行 ${idxRows.length.toLocaleString()} / 部門行 ${tseRows.length.toLocaleString()}`;
}

/* ========= init ========= */
function init(){
  idxCanvas = document.getElementById("idxChart");
  tseCanvas = document.getElementById("tseChart");
  idxCtx = idxCanvas.getContext("2d");
  tseCtx = tseCanvas.getContext("2d");
  tooltip = document.getElementById("tooltip");

  bindControls();
  const doResize = ()=>{
    resizeCanvas(idxCanvas);
    resizeCanvas(tseCanvas);
    redrawAll();
  };
  window.addEventListener("resize", doResize);
  doResize();

  for(const c of [idxCanvas, tseCanvas]){
    c.addEventListener("wheel", onWheelZoom, {passive:false});
    c.addEventListener("mousedown", (e)=>onMouseDown(e, c));
    c.addEventListener("mousemove", (e)=>{
      onMouseMove(e);
      if(!isDragging){
        const data = (c === idxCanvas ? idxData : tseData);
        showTooltipForCanvas(e, c, data);
      }
    });
    c.addEventListener("mouseup", onMouseUp);
    c.addEventListener("mouseleave", onMouseLeave);
  }
  window.addEventListener("mouseup", onMouseUp);

  autoLoad().catch(err=>{
    console.error(err);
    document.getElementById("status").textContent = `エラー: ${err.message}`;
  });
}
window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
