<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>株価指数 + 部門別売買動向チャート</title>
  <style>
    :root{
      --bg:#f5f5f7;
      --card:#ffffff;
      --text:#1f2328;
      --muted:#6b7280;
      --axisDark:#6b7280;
      --line:#e5e7eb;
      --chip:#f3f4f6;
      --shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    body{
      margin:0; padding:16px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg); color:var(--text);
    }
    .wrap{ width:100%; margin:0 auto; }
    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:14px; box-shadow:var(--shadow);
      padding:14px 16px;
      max-width:1400px;
      margin:0 auto;
    }
    .header{
      display:flex; align-items:baseline; gap:12px; flex-wrap:wrap;
    }
    .header h1{ margin:0; font-size:16px; letter-spacing:0.2px; }
    .sub{ font-size:12px; color:var(--muted); }
    .headerRight{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .rows{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

    .controls{
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .group{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fafafa;
      border-radius:12px;
    }
    .label{ font-weight:700; font-size:12px; color:#374151; }
    input[type="range"]{ width:260px; }
    input[type="number"]{
      width:86px; padding:6px 8px;
      border:1px solid #cfd4dc; border-radius:10px;
      background:#fff; font-size:13px; text-align:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      background:var(--chip);
      border-radius:999px;
      font-size:12px; color:#111827;
      white-space:nowrap;
    }
    .chip .muted{ color:var(--muted); }

    .grid2{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .chartCard{ border:1px solid var(--line); border-radius:12px; background:#fff; overflow:hidden; }
    .chartHead{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background:#fafafa;
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    .chartTitle{ font-weight:700; font-size:13px; color:#111827; margin-right:auto; }

    .legend{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .legend-item{ display:flex; align-items:center; gap:6px; font-size:12px; color:#374151; }
    .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.15); }

    .selRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      width:100%;
      padding:8px 0;
    }
    .sel{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:10px;
    }
    .sel .slot{
      width:16px;
      text-align:right;
      font-size:11px;
      color:var(--muted);
      flex:0 0 auto;
    }
    select{
      min-width:180px;
      padding:5px 6px;
      border:1px solid #cfd4dc;
      border-radius:8px;
      background:#fff;
      font-size:12px;
    }
    .color-picker{
      width:28px;
      height:28px;
      border:1px solid #cfd4dc;
      border-radius:6px;
      padding:0;
      cursor:pointer;
      background:none;
    }
    .show-check{
      width:18px;
      height:18px;
      margin-left:4px;
      cursor:pointer;
      accent-color:#2563eb;
    }
    .sel.disabled{
      opacity:0.4;
      pointer-events:none;
    }
    .sel.disabled select,
    .sel.disabled .color-picker{
      pointer-events:none;
    }
    .sel.disabled .show-check{
      pointer-events:auto;
    }

    .canvasBox{ position:relative; background:#fff; }
    canvas{ display:block; width:100%; cursor:crosshair; }
    #idxChart{ height:240px; }
    #tseChart{ height:480px; }

    .tooltip{
      position:fixed;
      background:rgba(255,255,255,0.98);
      border:1px solid #9ca3af; padding:8px 10px; border-radius:10px;
      font-size:12px; pointer-events:none; display:none;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:1000; line-height:1.45; white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <h1>株価指数 + 部門別売買動向チャート</h1>
        <span class="sub" id="status">読込中…</span>
        <div class="headerRight">
          <span class="chip" id="latestChip"><span class="muted">最新</span> -</span>
          <span class="chip" id="viewChip"><span class="muted">表示範囲</span> -</span>
        </div>
      </div>

      <div class="rows">
        <div class="controls">
          <div class="group">
            <div class="label">表示本数</div>
            <input id="countRange" type="range" min="10" max="700" step="1" value="200">
            <input id="countNum" type="number" min="10" max="700" step="1" value="200">
          </div>
          <div class="group">
            <div class="label">操作</div>
            <span class="chip"><span class="muted">ホイール</span> 拡大/縮小</span>
            <span class="chip"><span class="muted">ドラッグ</span> 横スクロール</span>
          </div>
        </div>

        <div class="grid2">
          <!-- 株価指数チャート（プルダウン1つ） -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">株価指数（PtoCSV_long.csv / list.csv）</div>
              <div class="legend" id="idxLegend"></div>
            </div>
            <div class="selRow" id="idxSelRow" style="padding:8px 12px;">
              <div class="sel">
                <div class="slot">銘柄</div>
                <select id="idxSel1"></select>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="idxChart"></canvas>
            </div>
          </div>

          <!-- 部門別売買動向チャート（プルダウン8個、色選択付き） -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">部門別売買動向（TSEPrime.csv）</div>
              <div class="legend" id="tseLegend"></div>
            </div>
            <div class="selRow" id="tseSelRow" style="padding:8px 12px;">
              <div class="sel"><div class="slot">1</div><select id="tseSel1"></select><input type="color" class="color-picker" id="tseColor1" value="#FF4B00"><input type="checkbox" class="show-check" id="tseCheck1" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">2</div><select id="tseSel2"></select><input type="color" class="color-picker" id="tseColor2" value="#005AFF"><input type="checkbox" class="show-check" id="tseCheck2" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">3</div><select id="tseSel3"></select><input type="color" class="color-picker" id="tseColor3" value="#03AF7A"><input type="checkbox" class="show-check" id="tseCheck3" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">4</div><select id="tseSel4"></select><input type="color" class="color-picker" id="tseColor4" value="#4DC4FF"><input type="checkbox" class="show-check" id="tseCheck4" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">5</div><select id="tseSel5"></select><input type="color" class="color-picker" id="tseColor5" value="#F6AA00"><input type="checkbox" class="show-check" id="tseCheck5" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">6</div><select id="tseSel6"></select><input type="color" class="color-picker" id="tseColor6" value="#990099"><input type="checkbox" class="show-check" id="tseCheck6" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">7</div><select id="tseSel7"></select><input type="color" class="color-picker" id="tseColor7" value="#84919E"><input type="checkbox" class="show-check" id="tseCheck7" checked title="表示/非表示"></div>
              <div class="sel"><div class="slot">8</div><select id="tseSel8"></select><input type="color" class="color-picker" id="tseColor8" value="#000000"><input type="checkbox" class="show-check" id="tseCheck8" checked title="表示/非表示"></div>
            </div>
            <div class="canvasBox">
              <canvas id="tseChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
  </div>

<script>
/* ========= colors ========= */
const DEFAULT_COLORS = ["#FF4B00","#005AFF","#03AF7A","#4DC4FF","#F6AA00","#990099","#84919E","#000000"];
const MAX_DISPLAY = 700;
const TSE_SELECTION_COUNT = 8;

/* ========= TSEPrime: 英語列名 -> 日本語表示名 ========= */
const TSEPRIME_FIELD_MAP = {
  PropSell: "自己計_売",   PropBuy:"自己計_買",   PropTot:"自己計_合計",   PropBal:"自己計_差引",
  BrkSell: "委託計_売",    BrkBuy:"委託計_買",    BrkTot:"委託計_合計",    BrkBal:"委託計_差引",
  TotSell: "総計_売",      TotBuy:"総計_買",      TotTot:"総計_合計",      TotBal:"総計_差引",
  IndSell: "個人_売",      IndBuy:"個人_買",      IndTot:"個人_合計",      IndBal:"個人_差引",
  FrgnSell:"海外投資家_売",FrgnBuy:"海外投資家_買",FrgnTot:"海外投資家_合計",FrgnBal:"海外投資家_差引",
  SecCoSell:"証券会社_売", SecCoBuy:"証券会社_買", SecCoTot:"証券会社_合計", SecCoBal:"証券会社_差引",
  InvTrSell:"投資信託_売", InvTrBuy:"投資信託_買", InvTrTot:"投資信託_合計", InvTrBal:"投資信託_差引",
  BusCoSell:"事業法人_売", BusCoBuy:"事業法人_買", BusCoTot:"事業法人_合計", BusCoBal:"事業法人_差引",
  OthCoSell:"その他法人_売",OthCoBuy:"その他法人_買",OthCoTot:"その他法人_合計",OthCoBal:"その他法人_差引",
  InsCoSell:"生保・損保_売",InsCoBuy:"生保・損保_買",InsCoTot:"生保・損保_合計",InsCoBal:"生保・損保_差引",
  BankSell:"都銀・地銀等_売",BankBuy:"都銀・地銀等_買",BankTot:"都銀・地銀等_合計",BankBal:"都銀・地銀等_差引",
  TrstBnkSell:"信託銀行_売",TrstBnkBuy:"信託銀行_買",TrstBnkTot:"信託銀行_合計",TrstBnkBal:"信託銀行_差引",
  OthFinSell:"その他金融機関_売",OthFinBuy:"その他金融機関_買",OthFinTot:"その他金融機関_合計",OthFinBal:"その他金融機関_差引"
};

/* 差引項目のリスト（累積計算用） */
const BAL_FIELDS = [
  "自己計_差引", "委託計_差引", "総計_差引", "個人_差引",
  "海外投資家_差引", "証券会社_差引", "投資信託_差引", "事業法人_差引",
  "その他法人_差引", "生保・損保_差引", "都銀・地銀等_差引", "信託銀行_差引", "その他金融機関_差引"
];

/* ========= state ========= */
let idxRows = [];
let tseRows = [];
let idxDates = [];
let tseDates = [];
let globalDates = [];

let displayCount = 200;
let offsetX = 0;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;
let dragCanvas = null;

let idxCanvas, idxCtx, tseCanvas, tseCtx, tooltip;

let idxAvail = [];
let tseAvail = [];

let idxKey = "";
let tseKeys = new Array(TSE_SELECTION_COUNT).fill("");
let tseColors = [...DEFAULT_COLORS];
let tseVisible = new Array(TSE_SELECTION_COUNT).fill(true);

let idxData = null;
let tseData = null;

/* ========= helpers ========= */
function cleanHeaderValue(s){
  return String(s ?? "")
    .replace(/^\uFEFF/, "")
    .replace(/^"+|"+$/g, "")
    .trim();
}

function toNum(s){
  if(s==null) return NaN;
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim());
}
function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}
function uniqSorted(arr){
  const set = new Set(arr);
  const out = Array.from(set);
  out.sort((a,b)=>String(a).localeCompare(String(b)));
  return out;
}
function buildDateList(rows){
  const set = new Set();
  for(const r of rows){ if(r && r.date) set.add(r.date); }
  const arr = Array.from(set);
  arr.sort((a,b)=>{
    const ta=new Date(a).getTime(), tb=new Date(b).getTime();
    if(!Number.isNaN(ta) && !Number.isNaN(tb)) return ta-tb;
    return String(a).localeCompare(String(b));
  });
  return arr;
}
function buildGlobalDates(idxRows, tseRows){
  return buildDateList(idxRows.concat(tseRows));
}
function getVisibleWindowForDates(dates){
  const n = dates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const startRaw = n - count - localOffset;
  const endRaw = startRaw + count;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realDates = (start < end) ? dates.slice(start, end) : [];
  const realLen = realDates.length;

  const padN = count - realLen;
  const pads = new Array(Math.max(0,padN)).fill("");

  const visibleDates = pads.concat(realDates);
  const visibleAbsIndices = new Array(Math.max(0,padN)).fill(null).concat(
    Array.from({length: realLen}, (_,i)=> start + i)
  );
  return { visibleDates, visibleAbsIndices, startIndex: start, endIndex: end };
}
function buildDateIndex(dates){
  const map = new Map();
  dates.forEach((d,i)=>{ map.set(d, i); });
  return map;
}
function mapVisibleDatesToAbsIndices(dateIndex, visibleDates){
  return visibleDates.map(d => (d && dateIndex && dateIndex.has(d) ? dateIndex.get(d) : null));
}
function updateTopChips(){
  const latestEl = document.getElementById("latestChip");
  const viewEl = document.getElementById("viewChip");

  // 部門別データを基準にする（メインデータ）
  const baseDates = tseDates.length > 0 ? tseDates : globalDates;

  if(!baseDates || baseDates.length===0){
    latestEl.innerHTML = `<span class="muted">最新</span> -`;
    viewEl.innerHTML = `<span class="muted">表示範囲</span> -`;
    return;
  }
  latestEl.innerHTML = `<span class="muted">最新</span> ${baseDates[baseDates.length-1]}`;

  // 表示範囲を計算
  const n = baseDates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const start = Math.max(0, n - count - localOffset);
  const end = Math.min(n, start + count);

  const startDate = baseDates[start] || null;
  const endDate = baseDates[end - 1] || null;
  viewEl.innerHTML = `<span class="muted">表示範囲</span> ${startDate && endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}
function syncCountControls(){
  const r=document.getElementById('countRange');
  const n=document.getElementById('countNum');
  r.max=String(MAX_DISPLAY);
  n.max=String(MAX_DISPLAY);
  r.value=String(displayCount);
  n.value=String(displayCount);
}
function bindControls(){
  const countRange=document.getElementById('countRange');
  const countNum=document.getElementById('countNum');

  const setCount=(v)=>{
    const nn=Number(v);
    if(!Number.isFinite(nn)) return;
    const baseDates = getBaseDates();
    displayCount=Math.max(10, Math.min(Math.round(nn), MAX_DISPLAY, baseDates.length||MAX_DISPLAY));
    offsetX=0;
    countRange.value=String(displayCount);
    countNum.value=String(displayCount);
    updateTopChips();
    redrawAll();
  };

  countRange.addEventListener('input', ()=>setCount(countRange.value));
  countNum.addEventListener('change', ()=>setCount(countNum.value));
}

/* ========= encoding-safe fetch ========= */
async function fetchTextAutoEncoding(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`${url} fetch失敗: ${res.status} ${res.statusText}`);
  const buf = await res.arrayBuffer();

  const tUtf8 = new TextDecoder("utf-8", {fatal:false}).decode(buf);
  if (tUtf8.includes("PubDate") || tUtf8.includes("公表日") || tUtf8.includes("PropSell") || tUtf8.includes("自己計") || tUtf8.includes("日付")) {
    return tUtf8;
  }
  const tSjis = new TextDecoder("shift-jis", {fatal:false}).decode(buf);
  return tSjis;
}

/* ========= parsers ========= */
function parsePtoCsvToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("PtoCSV_long.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxDate=header.indexOf("日付");
  const idxName=header.indexOf("商品名");
  const idxVal=header.indexOf("数値");
  if(idxDate<0||idxName<0||idxVal<0) throw new Error("PtoCSV_long.csv: 必須列(日付, 商品名, 数値)が見つかりません");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;
    const date=(cols[idxDate]||"").trim();
    const name=(cols[idxName]||"").trim();
    const value=toNum(cols[idxVal]);
    if(!date || !name || Number.isNaN(value)) continue;
    rows.push({date, name, value});
  }
  return rows;
}

function parseTsePrimeToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("TSEPrime.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxPubDate=header.indexOf("PubDate") >= 0 ? header.indexOf("PubDate") : header.indexOf("公表日");
  const idxSection=header.indexOf("Section") >= 0 ? header.indexOf("Section") : header.indexOf("市場名");
  if(idxPubDate<0) throw new Error("TSEPrime.csv: 必須列(PubDate/公表日)が見つかりません");

  const fieldDefs = Object.entries(TSEPRIME_FIELD_MAP)
    .map(([en, jp]) => ({ jp, idx: header.indexOf(en) >= 0 ? header.indexOf(en) : header.indexOf(jp) }))
    .filter(x => x.idx >= 0);

  if(fieldDefs.length===0) throw new Error("TSEPrime.csv: 数値列が見つかりません（Field map 不一致 / 文字化けの可能性）");

  let sectionFilter = null;
  if(idxSection >= 0){
    const hasTsePrime = lines.slice(1).some(line => {
      const cols = parseDelimitedLine(line, delim);
      const section = (cols[idxSection] || "").trim();
      return section === "TSEPrime";
    });
    if(hasTsePrime) sectionFilter = "TSEPrime";
  }

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;

    if(idxSection >= 0 && sectionFilter){
      const section=(cols[idxSection]||"").trim();
      if(section!==sectionFilter) continue;
    }

    const date=(cols[idxPubDate]||"").trim();
    if(!date) continue;

    for(const f of fieldDefs){
      const value=toNum(cols[f.idx]);
      if(Number.isNaN(value)) continue;
      rows.push({date, name: f.jp, value});
    }
  }
  return rows;
}

/* ========= list loaders ========= */
async function loadNameList(filename){
  async function fetchText(decoderName){
    const res = await fetch(filename, {cache:'no-store'});
    if(!res.ok) return null;
    const buf = await res.arrayBuffer();
    const dec = new TextDecoder(decoderName, {fatal:false});
    return dec.decode(buf);
  }
  function parseToNames(text){
    if(!text) return null;
    const lines = text.split(/\r?\n/);
    const out = [];
    for(const raw of lines){
      let line = String(raw||"");
      line = line.replace(/^\uFEFF/, "").trim();
      if(!line || line.startsWith('#')) continue;
      const first = line.split(/\t|,/)[0].replace(/^"+|"+$/g,'').trim();
      if(first) out.push(first);
    }
    const seen = new Set();
    const uniq = [];
    for(const n of out){
      if(seen.has(n)) continue;
      seen.add(n);
      uniq.push(n);
    }
    return uniq.length ? uniq : null;
  }

  const tUtf8 = await fetchText('utf-8');
  const nUtf8 = parseToNames(tUtf8);

  const tSjis = await fetchText('shift-jis');
  const nSjis = parseToNames(tSjis);

  if(!nUtf8 && !nSjis) return null;
  if(nUtf8 && !nSjis) return nUtf8;
  if(!nUtf8 && nSjis) return nSjis;
  return (nSjis.length > nUtf8.length ? nSjis : nUtf8);
}

/* ========= series building ========= */
function buildIdxSeries(rows, key, dates){
  if(!key) return { dates, series: [] };
  const map = new Map();
  for(const r of rows){ if(r.name===key) map.set(r.date, r.value); }
  const values = dates.map(d => (map.has(d) ? map.get(d) : null));
  return { dates, series: [{ label: key, color: "#2563eb", width: 2, values }] };
}

function buildTseSeries(rows, keys, colors, dates, visible){
  const series = [];

  // 差引累計が1つでも選択されているかチェック
  const hasCumulative = keys.some((k, i) => k && k.endsWith("_差引累計") && visible[i]);

  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    if(!k) continue;
    if(!visible[i]) continue; // チェックが外れていたらスキップ

    // 累積計算かどうかをチェック
    const isCumulative = k.endsWith("_差引累計");

    // 差引累計がある場合、差引累計以外はスキップ
    if(hasCumulative && !isCumulative) continue;

    const baseKey = isCumulative ? k.replace("_差引累計", "_差引") : k;

    const map = new Map();
    for(const r of rows){ if(r.name===baseKey) map.set(r.date, r.value); }

    let values;
    if(isCumulative){
      // 全範囲で累積計算（描画時に表示範囲でオフセット調整）
      values = [];
      let cumulative = 0;
      for(let j=0; j<dates.length; j++){
        const d = dates[j];
        const v = map.has(d) ? map.get(d) : null;
        if(v !== null){
          cumulative += v;
        }
        values.push(cumulative);
      }
    } else {
      values = dates.map(d => (map.has(d) ? map.get(d) : null));
    }

    series.push({ label: k, color: colors[i] || DEFAULT_COLORS[i % DEFAULT_COLORS.length], width: 2, values, isCumulative, slotIndex: i });
  }
  return { dates, series };
}

/* ========= draw ========= */
function renderLegend(elId, data){
  const box = document.getElementById(elId);
  if(!box) return;
  box.innerHTML = '';
  if(!data || !data.series || data.series.length===0) return;
  for(const s of data.series){
    const item = document.createElement('div');
    item.className = 'legend-item';
    const sw = document.createElement('span');
    sw.className = 'swatch';
    sw.style.background = s.color;
    item.appendChild(sw);
    const txt = document.createElement('span');
    txt.textContent = s.label;
    item.appendChild(txt);
    box.appendChild(item);
  }
}

function drawChartGeneric(ctx, canvas, data, visibleDates, visibleAbsIndices){
  const w=canvas.width, h=canvas.height;
  const pad={t:14,b:28,l:12,r:90};
  const chartW=w-pad.l-pad.r;
  const chartH=h-pad.t-pad.b;

  ctx.clearRect(0,0,w,h);

  ctx.font = "12px -apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif";

  if(!data || !data.series || data.series.length===0 || !data.dates || data.dates.length===0){
    ctx.fillStyle='#6b7280';
    ctx.textAlign='center';
    ctx.fillText("データを選択してください", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  // 累積データのオフセットを計算（表示範囲の最初の有効な値を0とする）
  const seriesOffsets = data.series.map(s => {
    if(!s.isCumulative) return 0;
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx != null && s.values[absIdx] != null && !Number.isNaN(s.values[absIdx])){
        return s.values[absIdx];
      }
    }
    return 0;
  });

  // 値取得関数（累積の場合はオフセット調整）
  const getValue = (s, absIdx, seriesIdx) => {
    const v = s.values[absIdx];
    if(v == null || Number.isNaN(v)) return null;
    if(s.isCumulative) return v - seriesOffsets[seriesIdx];
    return v;
  };

  let minV=Infinity, maxV=-Infinity;
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx==null) continue;
      const v = getValue(s, absIdx, si);
      if(v==null) continue;
      minV=Math.min(minV,v); maxV=Math.max(maxV,v);
    }
  }
  if(minV===Infinity){
    ctx.fillStyle='#6b7280'; ctx.textAlign='center'; ctx.fillText("表示範囲にデータがありません", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  const range=(maxV-minV)||1;
  minV -= range*0.06;
  maxV += range*0.06;

  const scaleY=chartH/(maxV-minV);
  const getX=(i)=>pad.l+(i+0.5)*(chartW/visibleDates.length);
  const getY=(val)=>pad.t+chartH-(val-minV)*scaleY;

  ctx.strokeStyle='#eef0f3'; ctx.lineWidth=1;
  const gridSteps=5;
  for(let i=0;i<=gridSteps;i++){
    const y=pad.t+(chartH*i/gridSteps);
    const v=maxV-(maxV-minV)*(i/gridSteps);
    ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
    ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
    // 数値を見やすい形式で表示（大きい数値は億単位など）
    const formattedVal = formatAxisValue(v);
    ctx.fillText(formattedVal, w-pad.r+6, y+4);
  }

  visibleDates.forEach((d,i)=>{
    if(d && i % Math.ceil(visibleDates.length/6)===0){
      ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--axisDark').trim() || '#6b7280';
      ctx.textAlign='center';
      ctx.fillText(d, getX(i), h-6);
    }
  });

  // ツールチップ用にオフセット情報も保存
  canvas.pointPositions = visibleDates.map((d,i)=>({
    x:getX(i),
    w:chartW/visibleDates.length,
    absIndex:visibleAbsIndices[i],
    date:d
  }));
  canvas.seriesOffsets = seriesOffsets;

  // 各系列を描画
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    const color = s.color || '#000000';
    const lineWidth = s.width || 2;

    // 有効なデータポイントを収集
    const validPoints = [];
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx == null) continue;
      const v = getValue(s, absIdx, si);
      if(v == null || !Number.isFinite(v)) continue;
      const x = getX(i);
      const y = getY(v);
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      validPoints.push({x, y});
    }

    // 線を描画（有効なポイント間を連続して繋ぐ）
    if(validPoints.length >= 2){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(validPoints[0].x, validPoints[0].y);
      for(let i=1; i<validPoints.length; i++){
        ctx.lineTo(validPoints[i].x, validPoints[i].y);
      }
      ctx.stroke();
      ctx.restore();
    } else if(validPoints.length === 1){
      // 1点のみの場合は小さな円で表示
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(validPoints[0].x, validPoints[0].y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function formatAxisValue(v){
  const absV = Math.abs(v);
  if(absV >= 1e12){
    return (v / 1e12).toFixed(1) + "兆";
  } else if(absV >= 1e8){
    return (v / 1e8).toFixed(1) + "億";
  } else if(absV >= 1e4){
    return (v / 1e4).toFixed(0) + "万";
  } else {
    return v.toFixed(0);
  }
}

function resizeCanvas(canvas){
  const rect=canvas.getBoundingClientRect();
  canvas.width=Math.floor(rect.width);
  canvas.height=Math.floor(rect.height);
}

/* ========= tooltip ========= */
function fmt(n){
  return (n!==null && n!==undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined,{maximumFractionDigits:2})
    : '-';
}
function showTooltipForCanvas(e, canvas, data){
  const pps = canvas.pointPositions;
  if(!pps || !data) return;

  const rect=canvas.getBoundingClientRect();
  const mouseX=e.clientX-rect.left;

  const p = pps.find(pp => mouseX >= pp.x - pp.w/2 && mouseX <= pp.x + pp.w/2);
  if(!p){
    tooltip.style.display='none';
    return;
  }
  const absIdx = p.absIndex;
  const date = p.date || (absIdx!=null ? data.dates[absIdx] : "") || "";
  const offsets = canvas.seriesOffsets || [];
  let html = `<strong>${date}</strong><br>`;
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    let val = (absIdx!=null ? s.values[absIdx] : null);
    // 累積データの場合はオフセット調整
    if(val != null && s.isCumulative && offsets[si] != null){
      val = val - offsets[si];
    }
    html += `<span style="color:${s.color}; font-weight:700;">${s.label}</span>: ${fmt(val)}<br>`;
  }
  tooltip.innerHTML = html;
  tooltip.style.display='block';

  let tx=e.clientX+14, ty=e.clientY+14;
  if(tx+260>window.innerWidth) tx-=280;
  tooltip.style.left=tx+'px';
  tooltip.style.top=ty+'px';
}

/* ========= interactions (shared) ========= */
function getBaseDates(){
  return tseDates.length > 0 ? tseDates : globalDates;
}

function onWheelZoom(e){
  e.preventDefault();
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;

  const shrink = (e.deltaY < 0);
  displayCount += (shrink ? -1 : +1);
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, baseDates.length));

  offsetX = 0;

  syncCountControls();
  updateTopChips();
  redrawAll();
}
function onMouseDown(e, canvas){
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;
  isDragging = true;
  dragCanvas = canvas;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}
function onMouseMove(e){
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;

  if(isDragging){
    const canvas = dragCanvas || idxCanvas;
    const rect = canvas.getBoundingClientRect();
    const usableW = Math.max(1, rect.width - 120);
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, usableW / displayCount);
    const moveBars = diffX / ppc;

    const n = baseDates.length;
    const maxOffset = Math.max(0, n - displayCount);

    let newOffset = dragStartOffset + moveBars;
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = Math.round(newOffset);

    updateTopChips();
    redrawAll();
  }
}
function onMouseUp(){
  isDragging = false;
  dragCanvas = null;
  document.body.style.cursor = 'default';
}
function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display='none';
}

/* ========= redraw ========= */
function rebuildData(){
  // 指数データ
  idxData = buildIdxSeries(idxRows, idxKey, idxDates);
  idxData.dateIndex = buildDateIndex(idxDates);

  // 部門別データ
  tseData = buildTseSeries(tseRows, tseKeys, tseColors, tseDates, tseVisible);
  tseData.dateIndex = buildDateIndex(tseDates);

  renderLegend("idxLegend", idxData);
  renderLegend("tseLegend", tseData);

  // UIの状態を更新（差引累計がある場合は他を無効化）
  updateTseSelectionUI();
}

// 各チャート用の独立した表示範囲を計算
function getChartWindow(dates, baseDates){
  // baseDatesを基準に表示範囲を計算し、datesに適用
  const n = baseDates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const startRaw = n - count - localOffset;
  const endRaw = startRaw + count;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  // 基準となる日付範囲を取得
  const startDate = baseDates[start] || null;
  const endDate = baseDates[end - 1] || null;

  if(!startDate || !endDate || dates.length === 0){
    return { visibleDates: [], visibleAbsIndices: [] };
  }

  // datesから該当範囲の日付を抽出
  const filteredIndices = [];
  const filteredDates = [];
  for(let i = 0; i < dates.length; i++){
    const d = dates[i];
    if(d >= startDate && d <= endDate){
      filteredIndices.push(i);
      filteredDates.push(d);
    }
  }

  return { visibleDates: filteredDates, visibleAbsIndices: filteredIndices };
}

function redrawAll(){
  rebuildData(); // 累積計算のために毎回再構築

  // 部門別データがメイン: tseDatesを基準にする
  // 指数データはその範囲に合わせる
  const baseDates = tseDates.length > 0 ? tseDates : globalDates;

  // 部門別チャート: tseDatesを基準
  const tseWindow = getChartWindow(tseDates, baseDates);

  // 指数チャート: 同じ期間だがidxDatesで
  const idxWindow = getChartWindow(idxDates, baseDates);

  drawChartGeneric(idxCtx, idxCanvas, idxData, idxWindow.visibleDates, idxWindow.visibleAbsIndices);
  drawChartGeneric(tseCtx, tseCanvas, tseData, tseWindow.visibleDates, tseWindow.visibleAbsIndices);
}

/* ========= select UI ========= */
function updateTseSelectionUI(){
  // 差引累計が1つでも選択・表示されているかチェック
  const hasCumulative = tseKeys.some((k, i) => k && k.endsWith("_差引累計") && tseVisible[i]);

  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    const sel = document.getElementById(`tseSel${i+1}`);
    const colorPicker = document.getElementById(`tseColor${i+1}`);
    const checkbox = document.getElementById(`tseCheck${i+1}`);
    const selDiv = sel ? sel.closest('.sel') : null;

    if(!sel || !checkbox || !selDiv) continue;

    const k = tseKeys[i];
    const isCumulative = k && k.endsWith("_差引累計");

    // チェックボックスの状態を更新
    checkbox.checked = tseVisible[i];

    // 差引累計がある場合、差引累計以外は無効化表示
    if(hasCumulative && k && !isCumulative){
      selDiv.classList.add('disabled');
    } else {
      selDiv.classList.remove('disabled');
    }
  }
}

function fillIdxSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "— 選択してください —";
  selectEl.appendChild(optEmpty);
  for(const n of names){
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = n;
    selectEl.appendChild(opt);
  }
  selectEl.value = current || "";
}

function fillTseSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "— 選択 —";
  selectEl.appendChild(optEmpty);

  // 通常の項目を追加
  for(const n of names){
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = n;
    selectEl.appendChild(opt);
  }

  // 差引累計のオプションを追加（差引項目のみ）
  const balItems = names.filter(n => n.endsWith("_差引"));
  if(balItems.length > 0){
    const optGroup = document.createElement("optgroup");
    optGroup.label = "━━ 差引累計 ━━";
    for(const n of balItems){
      const opt = document.createElement("option");
      opt.value = n.replace("_差引", "_差引累計");
      opt.textContent = n.replace("_差引", "_差引累計");
      optGroup.appendChild(opt);
    }
    selectEl.appendChild(optGroup);
  }

  selectEl.value = current || "";
}

function bindSelects(){
  // 指数セレクト（1つのみ）
  const idxSel = document.getElementById("idxSel1");
  fillIdxSelect(idxSel, idxAvail, idxKey);
  idxSel.addEventListener("change", ()=>{
    idxKey = idxSel.value || "";
    try{ localStorage.setItem("idxKey_v3", idxKey); }catch(e){}
    redrawAll();
  });

  // 部門別セレクト（8つ）
  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    const sel = document.getElementById(`tseSel${i+1}`);
    const colorPicker = document.getElementById(`tseColor${i+1}`);
    const checkbox = document.getElementById(`tseCheck${i+1}`);

    fillTseSelect(sel, tseAvail, tseKeys[i]);
    colorPicker.value = tseColors[i];
    checkbox.checked = tseVisible[i];

    sel.addEventListener("change", ()=>{
      tseKeys[i] = sel.value || "";
      // 何かを選択したら表示をONにする
      if(tseKeys[i]) tseVisible[i] = true;
      try{ localStorage.setItem("tseKeys_v2", JSON.stringify(tseKeys)); }catch(e){}
      try{ localStorage.setItem("tseVisible_v1", JSON.stringify(tseVisible)); }catch(e){}
      redrawAll();
    });

    colorPicker.addEventListener("input", ()=>{
      tseColors[i] = colorPicker.value;
      try{ localStorage.setItem("tseColors_v1", JSON.stringify(tseColors)); }catch(e){}
      redrawAll();
    });

    checkbox.addEventListener("change", ()=>{
      tseVisible[i] = checkbox.checked;
      try{ localStorage.setItem("tseVisible_v1", JSON.stringify(tseVisible)); }catch(e){}
      redrawAll();
    });
  }
}

/* ========= main load ========= */
async function autoLoad(){
  const statusEl = document.getElementById("status");

  // 指数データ
  idxRows = [];
  try{
    statusEl.textContent = "PtoCSV_long.csv 読み込み中…";
    const txt1 = await fetchTextAutoEncoding("./PtoCSV_long.csv");
    idxRows = parsePtoCsvToLong(txt1);
  }catch(e){
    console.warn(e);
    statusEl.textContent = `PtoCSV_long.csv 読込エラー: ${e.message}`;
  }

  // 部門別データ
  tseRows = [];
  try{
    statusEl.textContent += " / TSEPrime.csv 読み込み中…";
    const txt2 = await fetchTextAutoEncoding("./data/TSEPrime.csv");
    tseRows = parseTsePrimeToLong(txt2);
  }catch(e){
    console.warn(e);
    statusEl.textContent += ` / TSEPrime 読込エラー: ${e.message}`;
  }

  // プルダウン用リスト
  const idxNamesFromData = uniqSorted(idxRows.map(r => r.name));
  const tseNamesFromData = uniqSorted(tseRows.map(r => r.name));

  let idxList = null;
  let tseList = null;
  try{ idxList = await loadNameList("./list.csv"); }catch(e){ console.warn(e); }
  try{ tseList = await loadNameList("./bumonlist.csv"); }catch(e){ console.warn(e); }

  idxAvail = (idxList ? idxList.filter(n => idxNamesFromData.includes(n)) : idxNamesFromData);
  if(idxAvail.length === 0) idxAvail = idxNamesFromData;

  tseAvail = (tseList ? tseList.filter(n => tseNamesFromData.includes(n)) : tseNamesFromData);
  if(tseAvail.length === 0) tseAvail = tseNamesFromData;

  // 日付軸
  idxDates = buildDateList(idxRows);
  tseDates = buildDateList(tseRows);
  globalDates = buildGlobalDates(idxRows, tseRows);

  // restore selections
  try{
    const raw = localStorage.getItem("idxKey_v3");
    if(raw && idxAvail.includes(raw)){
      idxKey = raw;
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseKeys_v2");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseKeys = new Array(TSE_SELECTION_COUNT).fill("").map((_, i)=> arr[i] || "");
      }
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseColors_v1");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseColors = new Array(TSE_SELECTION_COUNT).fill("").map((_, i)=> arr[i] || DEFAULT_COLORS[i]);
      }
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseVisible_v1");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseVisible = new Array(TSE_SELECTION_COUNT).fill(true).map((_, i)=> arr[i] !== false);
      }
    }
  }catch(e){}

  // デフォルト値設定
  if(!idxKey && idxAvail[0]) idxKey = idxAvail[0];

  // 部門別のデフォルト：海外投資家_差引累計、個人_差引累計など
  const defaultTseKeys = [
    "海外投資家_差引累計",
    "個人_差引累計",
    "信託銀行_差引累計",
    "投資信託_差引累計",
    "事業法人_差引累計",
    "",
    "",
    ""
  ];
  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    if(!tseKeys[i] && defaultTseKeys[i]) {
      // 累計の場合、ベースとなる差引が存在するかチェック
      const baseKey = defaultTseKeys[i].replace("_差引累計", "_差引");
      if(tseAvail.includes(baseKey)){
        tseKeys[i] = defaultTseKeys[i];
      }
    }
  }

  const baseDatesLoaded = tseDates.length > 0 ? tseDates : globalDates;
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, baseDatesLoaded.length || displayCount));
  offsetX = 0;
  syncCountControls();
  updateTopChips();

  bindSelects();
  redrawAll();

  statusEl.textContent =
    `ロード完了: 日付 ${globalDates.length.toLocaleString()} / 指数行 ${idxRows.length.toLocaleString()} / 部門行 ${tseRows.length.toLocaleString()}`;
}

/* ========= init ========= */
function init(){
  idxCanvas = document.getElementById("idxChart");
  tseCanvas = document.getElementById("tseChart");
  idxCtx = idxCanvas.getContext("2d");
  tseCtx = tseCanvas.getContext("2d");
  tooltip = document.getElementById("tooltip");

  bindControls();
  const doResize = ()=>{
    resizeCanvas(idxCanvas);
    resizeCanvas(tseCanvas);
    redrawAll();
  };
  window.addEventListener("resize", doResize);
  doResize();

  for(const c of [idxCanvas, tseCanvas]){
    c.addEventListener("wheel", onWheelZoom, {passive:false});
    c.addEventListener("mousedown", (e)=>onMouseDown(e, c));
    c.addEventListener("mousemove", (e)=>{
      onMouseMove(e);
      if(!isDragging){
        const data = (c === idxCanvas ? idxData : tseData);
        showTooltipForCanvas(e, c, data);
      }
    });
    c.addEventListener("mouseup", onMouseUp);
    c.addEventListener("mouseleave", onMouseLeave);
  }
  window.addEventListener("mouseup", onMouseUp);

  autoLoad().catch(err=>{
    console.error(err);
    document.getElementById("status").textContent = `エラー: ${err.message}`;
  });
}
window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
