<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>株価指数 + 部門別売買動向チャート</title>
  <style>
    :root{
      --bg:#f5f5f7;
      --card:#ffffff;
      --text:#1f2328;
      --muted:#6b7280;
      --axisDark:#6b7280;
      --line:#e5e7eb;
      --chip:#f3f4f6;
      --shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    body{
      margin:0; padding:16px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg); color:var(--text);
    }
    .wrap{ width:100%; margin:0 auto; }
    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:14px; box-shadow:var(--shadow);
      padding:14px 16px;
      max-width:1400px;
      margin:0 auto;
    }
    .header{
      display:flex; align-items:baseline; gap:12px; flex-wrap:wrap;
    }
    .header h1{ margin:0; font-size:16px; letter-spacing:0.2px; }
    .sub{ font-size:12px; color:var(--muted); }
    .headerRight{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .rows{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

    .controls{
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .group{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fafafa;
      border-radius:12px;
    }
    .label{ font-weight:700; font-size:12px; color:#374151; }
    input[type="range"]{ width:260px; }
    input[type="number"]{
      width:86px; padding:6px 8px;
      border:1px solid #cfd4dc; border-radius:10px;
      background:#fff; font-size:13px; text-align:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      background:var(--chip);
      border-radius:999px;
      font-size:12px; color:#111827;
      white-space:nowrap;
    }
    .chip .muted{ color:var(--muted); }

    .grid2{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .chartCard{ border:1px solid var(--line); border-radius:12px; background:#fff; overflow:hidden; }
    .chartHead{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background:#fafafa;
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    .chartTitle{ font-weight:700; font-size:13px; color:#111827; margin-right:auto; }

    .legend{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .legend-item{ display:flex; align-items:center; gap:6px; font-size:12px; color:#374151; }
    .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.15); }

    .selRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      width:100%;
      padding:8px 0;
    }
    #tseSelContainer{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      flex:1;
    }
    #tseSelContainer.hidden{
      display:none;
    }
    .sel{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:10px;
    }
    .sel .slot{
      width:16px;
      text-align:right;
      font-size:11px;
      color:var(--muted);
      flex:0 0 auto;
    }
    select{
      min-width:180px;
      padding:5px 6px;
      border:1px solid #cfd4dc;
      border-radius:8px;
      background:#fff;
      font-size:12px;
    }
    .color-picker{
      width:28px;
      height:28px;
      border:1px solid #cfd4dc;
      border-radius:6px;
      padding:0;
      cursor:pointer;
      background:none;
    }
    .show-check{
      width:18px;
      height:18px;
      margin-left:4px;
      cursor:pointer;
      accent-color:#2563eb;
    }
    .sel.disabled{
      opacity:0.5;
    }
    .sel.disabled .slot{
      color:#9ca3af;
    }

    .canvasBox{ position:relative; background:#fff; }
    canvas{ display:block; width:100%; cursor:crosshair; }

    .toggle-btn{
      width:28px; height:28px;
      border:1px solid #cfd4dc;
      border-radius:6px;
      background:#fff;
      font-size:18px;
      font-weight:bold;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#374151;
      flex-shrink:0;
    }
    .toggle-btn:hover{
      background:#f3f4f6;
    }
    #idxChart{ height:240px; }
    #tseChart{ height:480px; }

    .tooltip{
      position:fixed;
      background:rgba(255,255,255,0.98);
      border:1px solid #9ca3af; padding:8px 10px; border-radius:10px;
      font-size:12px; pointer-events:none; display:none;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:1000; line-height:1.45; white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <h1>株価指数 + 部門別売買動向チャート</h1>
        <span class="sub" id="status">読込中…</span>
        <div class="headerRight">
          <span class="chip" id="latestChip"><span class="muted">最新</span> -</span>
          <span class="chip" id="viewChip"><span class="muted">表示範囲</span> -</span>
        </div>
      </div>

      <div class="rows">
        <div class="controls">
          <div class="group">
            <div class="label">表示本数</div>
            <input id="countRange" type="range" min="10" max="700" step="1" value="200">
            <input id="countNum" type="number" min="10" max="700" step="1" value="200">
            <label style="display:flex; align-items:center; gap:4px; margin-left:12px; font-size:12px; cursor:pointer;">
              <input type="checkbox" id="showDateLine" checked style="width:16px; height:16px; accent-color:#2563eb;">
              日付ライン
            </label>
          </div>
        </div>

        <div class="grid2">
          <!-- 株価指数チャート（プルダウン1つ） -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">株価指数</div>
              <div class="legend" id="idxLegend"></div>
            </div>
            <div class="selRow" id="idxSelRow" style="padding:8px 12px;">
              <div class="sel">
                <div class="slot">銘柄</div>
                <select id="idxSel1"></select>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="idxChart"></canvas>
            </div>
          </div>

          <!-- 部門別売買動向チャート（プルダウン8個、色選択付き） -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">部門別売買動向</div>
              <div class="legend" id="tseLegend"></div>
            </div>
            <div class="selRow" id="tseSelRow" style="padding:8px 12px;">
              <div id="tseSelContainer">
                <div class="sel"><div class="slot">1</div><select id="tseSel1"></select><input type="color" class="color-picker" id="tseColor1" value="#FF4B00"><input type="checkbox" class="show-check" id="tseCheck1" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">2</div><select id="tseSel2"></select><input type="color" class="color-picker" id="tseColor2" value="#005AFF"><input type="checkbox" class="show-check" id="tseCheck2" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">3</div><select id="tseSel3"></select><input type="color" class="color-picker" id="tseColor3" value="#03AF7A"><input type="checkbox" class="show-check" id="tseCheck3" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">4</div><select id="tseSel4"></select><input type="color" class="color-picker" id="tseColor4" value="#4DC4FF"><input type="checkbox" class="show-check" id="tseCheck4" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">5</div><select id="tseSel5"></select><input type="color" class="color-picker" id="tseColor5" value="#F6AA00"><input type="checkbox" class="show-check" id="tseCheck5" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">6</div><select id="tseSel6"></select><input type="color" class="color-picker" id="tseColor6" value="#990099"><input type="checkbox" class="show-check" id="tseCheck6" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">7</div><select id="tseSel7"></select><input type="color" class="color-picker" id="tseColor7" value="#84919E"><input type="checkbox" class="show-check" id="tseCheck7" checked title="表示/非表示"></div>
                <div class="sel"><div class="slot">8</div><select id="tseSel8"></select><input type="color" class="color-picker" id="tseColor8" value="#000000"><input type="checkbox" class="show-check" id="tseCheck8" checked title="表示/非表示"></div>
              </div>
              <button class="toggle-btn" id="tseToggleBtn" title="プルダウンの表示/非表示">－</button>
            </div>
            <div class="canvasBox">
              <canvas id="tseChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
  </div>

<script>
/* ========= colors ========= */
const DEFAULT_COLORS = ["#FF4B00","#005AFF","#03AF7A","#4DC4FF","#F6AA00","#990099","#84919E","#000000"];
const MAX_DISPLAY = 700;
const TSE_SELECTION_COUNT = 8;

/* ========= TSEPrime: 英語列名 -> 日本語表示名 ========= */
const TSEPRIME_FIELD_MAP = {
  PropSell: "自己計_売",   PropBuy:"自己計_買",   PropTot:"自己計_合計",   PropBal:"自己計_差引",
  BrkSell: "委託計_売",    BrkBuy:"委託計_買",    BrkTot:"委託計_合計",    BrkBal:"委託計_差引",
  TotSell: "総計_売",      TotBuy:"総計_買",      TotTot:"総計_合計",      TotBal:"総計_差引",
  IndSell: "個人_売",      IndBuy:"個人_買",      IndTot:"個人_合計",      IndBal:"個人_差引",
  FrgnSell:"海外投資家_売",FrgnBuy:"海外投資家_買",FrgnTot:"海外投資家_合計",FrgnBal:"海外投資家_差引",
  SecCoSell:"証券会社_売", SecCoBuy:"証券会社_買", SecCoTot:"証券会社_合計", SecCoBal:"証券会社_差引",
  InvTrSell:"投資信託_売", InvTrBuy:"投資信託_買", InvTrTot:"投資信託_合計", InvTrBal:"投資信託_差引",
  BusCoSell:"事業法人_売", BusCoBuy:"事業法人_買", BusCoTot:"事業法人_合計", BusCoBal:"事業法人_差引",
  OthCoSell:"その他法人_売",OthCoBuy:"その他法人_買",OthCoTot:"その他法人_合計",OthCoBal:"その他法人_差引",
  InsCoSell:"生保・損保_売",InsCoBuy:"生保・損保_買",InsCoTot:"生保・損保_合計",InsCoBal:"生保・損保_差引",
  BankSell:"都銀・地銀等_売",BankBuy:"都銀・地銀等_買",BankTot:"都銀・地銀等_合計",BankBal:"都銀・地銀等_差引",
  TrstBnkSell:"信託銀行_売",TrstBnkBuy:"信託銀行_買",TrstBnkTot:"信託銀行_合計",TrstBnkBal:"信託銀行_差引",
  OthFinSell:"その他金融機関_売",OthFinBuy:"その他金融機関_買",OthFinTot:"その他金融機関_合計",OthFinBal:"その他金融機関_差引"
};

/* 差引項目のリスト（累積計算用） */
const BAL_FIELDS = [
  "自己計_差引", "委託計_差引", "総計_差引", "個人_差引",
  "海外投資家_差引", "証券会社_差引", "投資信託_差引", "事業法人_差引",
  "その他法人_差引", "生保・損保_差引", "都銀・地銀等_差引", "信託銀行_差引", "その他金融機関_差引"
];

/* ========= state ========= */
let idxRows = [];
let tseRows = [];
let idxDates = [];
let tseDates = [];
let globalDates = [];

let displayCount = 200;
let offsetX = 0;
let showDateLine = true;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;
let dragCanvas = null;

let idxCanvas, idxCtx, tseCanvas, tseCtx, tooltip;

let idxAvail = [];
let tseAvail = [];

let idxKey = "";
let tseKeys = new Array(TSE_SELECTION_COUNT).fill("");
let tseColors = [...DEFAULT_COLORS];
let tseVisible = new Array(TSE_SELECTION_COUNT).fill(true);

let idxData = null;
let tseData = null;

/* ========= helpers ========= */
function cleanHeaderValue(s){
  return String(s ?? "")
    .replace(/^\uFEFF/, "")
    .replace(/^"+|"+$/g, "")
    .trim();
}

function toNum(s){
  if(s==null) return NaN;
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim());
}
function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}
function uniqSorted(arr){
  const set = new Set(arr);
  const out = Array.from(set);
  out.sort((a,b)=>String(a).localeCompare(String(b)));
  return out;
}
function buildDateList(rows){
  const set = new Set();
  for(const r of rows){ if(r && r.date) set.add(r.date); }
  const arr = Array.from(set);
  arr.sort((a,b)=>{
    const ta=new Date(a).getTime(), tb=new Date(b).getTime();
    if(!Number.isNaN(ta) && !Number.isNaN(tb)) return ta-tb;
    return String(a).localeCompare(String(b));
  });
  return arr;
}
function buildGlobalDates(idxRows, tseRows){
  return buildDateList(idxRows.concat(tseRows));
}
function getVisibleWindowForDates(dates){
  const n = dates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const startRaw = n - count - localOffset;
  const endRaw = startRaw + count;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realDates = (start < end) ? dates.slice(start, end) : [];
  const realLen = realDates.length;

  const padN = count - realLen;
  const pads = new Array(Math.max(0,padN)).fill("");

  const visibleDates = pads.concat(realDates);
  const visibleAbsIndices = new Array(Math.max(0,padN)).fill(null).concat(
    Array.from({length: realLen}, (_,i)=> start + i)
  );
  return { visibleDates, visibleAbsIndices, startIndex: start, endIndex: end };
}
function buildDateIndex(dates){
  const map = new Map();
  dates.forEach((d,i)=>{ map.set(d, i); });
  return map;
}
function mapVisibleDatesToAbsIndices(dateIndex, visibleDates){
  return visibleDates.map(d => (d && dateIndex && dateIndex.has(d) ? dateIndex.get(d) : null));
}
function updateTopChips(){
  const latestEl = document.getElementById("latestChip");
  const viewEl = document.getElementById("viewChip");

  // 部門別データを基準にする（メインデータ）
  const baseDates = tseDates.length > 0 ? tseDates : globalDates;

  if(!baseDates || baseDates.length===0){
    latestEl.innerHTML = `<span class="muted">最新</span> -`;
    viewEl.innerHTML = `<span class="muted">表示範囲</span> -`;
    return;
  }
  latestEl.innerHTML = `<span class="muted">最新</span> ${baseDates[baseDates.length-1]}`;

  // 表示範囲を計算
  const n = baseDates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const start = Math.max(0, n - count - localOffset);
  const end = Math.min(n, start + count);

  const startDate = baseDates[start] || null;
  const endDate = baseDates[end - 1] || null;
  viewEl.innerHTML = `<span class="muted">表示範囲</span> ${startDate && endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}
function syncCountControls(){
  const r=document.getElementById('countRange');
  const n=document.getElementById('countNum');
  r.max=String(MAX_DISPLAY);
  n.max=String(MAX_DISPLAY);
  r.value=String(displayCount);
  n.value=String(displayCount);
}
function bindControls(){
  const countRange=document.getElementById('countRange');
  const countNum=document.getElementById('countNum');

  const setCount=(v)=>{
    const nn=Number(v);
    if(!Number.isFinite(nn)) return;
    const baseDates = getBaseDates();
    displayCount=Math.max(10, Math.min(Math.round(nn), MAX_DISPLAY, baseDates.length||MAX_DISPLAY));
    offsetX=0;
    countRange.value=String(displayCount);
    countNum.value=String(displayCount);
    updateTopChips();
    redrawAll();
  };

  countRange.addEventListener('input', ()=>setCount(countRange.value));
  countNum.addEventListener('change', ()=>setCount(countNum.value));

  // 日付ラインチェックボックス
  const dateLineCheck = document.getElementById('showDateLine');
  dateLineCheck.checked = showDateLine;
  dateLineCheck.addEventListener('change', ()=>{
    showDateLine = dateLineCheck.checked;
    redrawAll();
  });
}

/* ========= encoding-safe fetch ========= */
async function fetchTextAutoEncoding(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`${url} fetch失敗: ${res.status} ${res.statusText}`);
  const buf = await res.arrayBuffer();

  const tUtf8 = new TextDecoder("utf-8", {fatal:false}).decode(buf);
  if (tUtf8.includes("PubDate") || tUtf8.includes("公表日") || tUtf8.includes("PropSell") || tUtf8.includes("自己計") || tUtf8.includes("日付")) {
    return tUtf8;
  }
  const tSjis = new TextDecoder("shift-jis", {fatal:false}).decode(buf);
  return tSjis;
}

/* ========= parsers ========= */
function parsePtoCsvToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("PtoCSV_long.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxDate=header.indexOf("日付");
  const idxName=header.indexOf("商品名");
  const idxVal=header.indexOf("数値");
  if(idxDate<0||idxName<0||idxVal<0) throw new Error("PtoCSV_long.csv: 必須列(日付, 商品名, 数値)が見つかりません");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;
    const date=(cols[idxDate]||"").trim();
    const name=(cols[idxName]||"").trim();
    const value=toNum(cols[idxVal]);
    if(!date || !name || Number.isNaN(value)) continue;
    rows.push({date, name, value});
  }
  return rows;
}

function parseTsePrimeToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("TSEPrime.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(cleanHeaderValue);

  const idxPubDate=header.indexOf("PubDate") >= 0 ? header.indexOf("PubDate") : header.indexOf("公表日");
  const idxSection=header.indexOf("Section") >= 0 ? header.indexOf("Section") : header.indexOf("市場名");
  if(idxPubDate<0) throw new Error("TSEPrime.csv: 必須列(PubDate/公表日)が見つかりません");

  const fieldDefs = Object.entries(TSEPRIME_FIELD_MAP)
    .map(([en, jp]) => ({ jp, idx: header.indexOf(en) >= 0 ? header.indexOf(en) : header.indexOf(jp) }))
    .filter(x => x.idx >= 0);

  if(fieldDefs.length===0) throw new Error("TSEPrime.csv: 数値列が見つかりません（Field map 不一致 / 文字化けの可能性）");

  let sectionFilter = null;
  if(idxSection >= 0){
    const hasTsePrime = lines.slice(1).some(line => {
      const cols = parseDelimitedLine(line, delim);
      const section = (cols[idxSection] || "").trim();
      return section === "TSEPrime";
    });
    if(hasTsePrime) sectionFilter = "TSEPrime";
  }

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;

    if(idxSection >= 0 && sectionFilter){
      const section=(cols[idxSection]||"").trim();
      if(section!==sectionFilter) continue;
    }

    const date=(cols[idxPubDate]||"").trim();
    if(!date) continue;

    for(const f of fieldDefs){
      const value=toNum(cols[f.idx]);
      if(Number.isNaN(value)) continue;
      rows.push({date, name: f.jp, value});
    }
  }
  return rows;
}

/* ========= list loaders ========= */
async function loadNameList(filename){
  async function fetchText(decoderName){
    const res = await fetch(filename, {cache:'no-store'});
    if(!res.ok) return null;
    const buf = await res.arrayBuffer();
    const dec = new TextDecoder(decoderName, {fatal:false});
    return dec.decode(buf);
  }
  function parseToNames(text, forBumonList = false){
    if(!text) return null;
    const lines = text.split(/\r?\n/);
    const out = [];
    let afterDisplayOrder = false;

    for(const raw of lines){
      let line = String(raw||"");
      line = line.replace(/^\uFEFF/, "");
      if(!line.trim() || line.trim().startsWith('#')) continue;

      // bumonlist.csvの場合、●表示順●以降のみを取得
      if(forBumonList){
        if(line.includes("●表示順●")){
          afterDisplayOrder = true;
          continue;
        }
        if(!afterDisplayOrder) continue;
      }

      const first = line.split(/\t|,/)[0].replace(/^"+|"+$/g,'');
      if(first.trim()) out.push(first); // トリムしないで保持（├─などのプレフィックス保持）
    }

    const seen = new Set();
    const uniq = [];
    for(const n of out){
      if(seen.has(n)) continue;
      seen.add(n);
      uniq.push(n);
    }
    return uniq.length ? uniq : null;
  }

  const isBumonList = filename.includes('bumonlist');

  const tUtf8 = await fetchText('utf-8');
  const nUtf8 = parseToNames(tUtf8, isBumonList);

  const tSjis = await fetchText('shift-jis');
  const nSjis = parseToNames(tSjis, isBumonList);

  if(!nUtf8 && !nSjis) return null;
  if(nUtf8 && !nSjis) return nUtf8;
  if(!nUtf8 && nSjis) return nSjis;
  return (nSjis.length > nUtf8.length ? nSjis : nUtf8);
}

/* ========= series building ========= */
function buildIdxSeries(rows, key, dates){
  if(!key) return { dates, series: [] };
  const map = new Map();
  for(const r of rows){ if(r.name===key) map.set(r.date, r.value); }
  const values = dates.map(d => (map.has(d) ? map.get(d) : null));
  return { dates, series: [{ label: key, color: "#2563eb", width: 2, values }] };
}

// 合成項目の定義（複数の差引を合計して計算）
const COMPOSITE_FIELDS = {
  "金融_差引累計": ["生保・損保_差引", "都銀・地銀等_差引", "信託銀行_差引", "その他金融機関_差引"],
  "法人_差引累計": ["事業法人_差引", "その他法人_差引"]
};

function buildTseSeries(rows, keys, colors, dates, visible){
  const series = [];

  // 差引累計が1つでも選択されているかチェック
  const hasCumulative = keys.some((k, i) => k && k.endsWith("_差引累計") && visible[i]);

  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    if(!k) continue;
    if(!visible[i]) continue; // チェックが外れていたらスキップ

    // 累積計算かどうかをチェック
    const isCumulative = k.endsWith("_差引累計");

    // 差引累計がある場合、差引累計以外はスキップ
    if(hasCumulative && !isCumulative) continue;

    // 合成項目（金融_差引累計、法人_差引累計）かどうかをチェック
    const isComposite = COMPOSITE_FIELDS.hasOwnProperty(k);

    let values;
    if(isComposite){
      // 合成項目の場合、複数の差引を合計して累積計算
      const baseKeys = COMPOSITE_FIELDS[k];
      const maps = baseKeys.map(baseKey => {
        const m = new Map();
        for(const r of rows){ if(r.name === baseKey) m.set(r.date, r.value); }
        return m;
      });

      values = [];
      let cumulative = 0;
      for(let j=0; j<dates.length; j++){
        const d = dates[j];
        let sum = 0;
        let hasValue = false;
        for(const m of maps){
          const v = m.has(d) ? m.get(d) : null;
          if(v !== null){
            sum += v;
            hasValue = true;
          }
        }
        if(hasValue){
          cumulative += sum;
        }
        values.push(cumulative);
      }
    } else if(isCumulative){
      // 通常の累積計算
      const baseKey = k.replace("_差引累計", "_差引");
      const map = new Map();
      for(const r of rows){ if(r.name===baseKey) map.set(r.date, r.value); }

      values = [];
      let cumulative = 0;
      for(let j=0; j<dates.length; j++){
        const d = dates[j];
        const v = map.has(d) ? map.get(d) : null;
        if(v !== null){
          cumulative += v;
        }
        values.push(cumulative);
      }
    } else {
      // 通常の値
      const map = new Map();
      for(const r of rows){ if(r.name===k) map.set(r.date, r.value); }
      values = dates.map(d => (map.has(d) ? map.get(d) : null));
    }

    series.push({ label: k, color: colors[i] || DEFAULT_COLORS[i % DEFAULT_COLORS.length], width: 2, values, isCumulative: isCumulative || isComposite, slotIndex: i });
  }
  return { dates, series };
}

/* ========= draw ========= */
function renderLegend(elId, data){
  const box = document.getElementById(elId);
  if(!box) return;
  box.innerHTML = '';
  if(!data || !data.series || data.series.length===0) return;
  for(const s of data.series){
    const item = document.createElement('div');
    item.className = 'legend-item';
    const sw = document.createElement('span');
    sw.className = 'swatch';
    sw.style.background = s.color;
    item.appendChild(sw);
    const txt = document.createElement('span');
    txt.textContent = s.label;
    item.appendChild(txt);
    box.appendChild(item);
  }
}

// キリのいい数値を計算（部門別売買動向用、千円単位）
function calcNiceTicks(minV, maxV, targetCount = 5){
  const range = maxV - minV;
  if(range === 0) return [minV];

  // 億円単位での範囲
  const rangeOku = range / 1e5;

  // キリのいい間隔を計算（億円単位）
  const niceIntervals = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000];
  const rawInterval = rangeOku / targetCount;

  let bestInterval = niceIntervals[0];
  for(const ni of niceIntervals){
    if(ni >= rawInterval){
      bestInterval = ni;
      break;
    }
    bestInterval = ni;
  }

  // 千円単位に戻す
  const interval = bestInterval * 1e5;

  // 開始値をキリのいい数値に
  const startTick = Math.floor(minV / interval) * interval;

  const ticks = [];
  for(let t = startTick; t <= maxV + interval * 0.5; t += interval){
    if(t >= minV - interval * 0.5){
      ticks.push(t);
    }
    if(ticks.length > 10) break;
  }

  return ticks;
}

function drawChartGeneric(ctx, canvas, data, visibleDates, visibleAbsIndices, isTseChart = false){
  const w=canvas.width, h=canvas.height;
  const pad={t:14,b:28,l:12,r:90};
  const chartW=w-pad.l-pad.r;
  const chartH=h-pad.t-pad.b;

  ctx.clearRect(0,0,w,h);

  ctx.font = "12px -apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif";

  if(!data || !data.series || data.series.length===0 || !data.dates || data.dates.length===0){
    ctx.fillStyle='#6b7280';
    ctx.textAlign='center';
    ctx.fillText("データを選択してください", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  // 累積データのオフセットを計算（表示範囲の最初の有効な値を0とする）
  const seriesOffsets = data.series.map(s => {
    if(!s.isCumulative) return 0;
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx != null && s.values[absIdx] != null && !Number.isNaN(s.values[absIdx])){
        return s.values[absIdx];
      }
    }
    return 0;
  });

  // 値取得関数（累積の場合はオフセット調整）
  const getValue = (s, absIdx, seriesIdx) => {
    const v = s.values[absIdx];
    if(v == null || Number.isNaN(v)) return null;
    if(s.isCumulative) return v - seriesOffsets[seriesIdx];
    return v;
  };

  let minV=Infinity, maxV=-Infinity;
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx==null) continue;
      const v = getValue(s, absIdx, si);
      if(v==null) continue;
      minV=Math.min(minV,v); maxV=Math.max(maxV,v);
    }
  }
  if(minV===Infinity){
    ctx.fillStyle='#6b7280'; ctx.textAlign='center'; ctx.fillText("表示範囲にデータがありません", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  const range=(maxV-minV)||1;

  // 部門別チャートの場合はキリのいい数値で範囲を設定
  let plotMinV, plotMaxV;
  let ticks = [];
  if(isTseChart){
    ticks = calcNiceTicks(minV, maxV, 5);
    plotMinV = ticks[0];
    plotMaxV = ticks[ticks.length - 1];
    // 範囲を少し広げる
    const tickRange = plotMaxV - plotMinV;
    plotMinV -= tickRange * 0.02;
    plotMaxV += tickRange * 0.02;
  } else {
    plotMinV = minV - range*0.06;
    plotMaxV = maxV + range*0.06;
  }

  const scaleY=chartH/(plotMaxV-plotMinV);
  const getX=(i)=>pad.l+(i+0.5)*(chartW/visibleDates.length);
  const getY=(val)=>pad.t+chartH-(val-plotMinV)*scaleY;

  ctx.strokeStyle='#eef0f3'; ctx.lineWidth=1;

  if(isTseChart && ticks.length > 0){
    // 部門別チャート：キリのいい数値でグリッド線
    for(const t of ticks){
      const y = getY(t);
      ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
      ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
      const formattedVal = formatTseAxisValue(t);
      ctx.fillText(formattedVal, w-pad.r+6, y+4);
    }
  } else {
    // 株価指数チャート：従来通り
    const gridSteps=5;
    for(let i=0;i<=gridSteps;i++){
      const y=pad.t+(chartH*i/gridSteps);
      const v=plotMaxV-(plotMaxV-plotMinV)*(i/gridSteps);
      ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
      ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
      const formattedVal = formatAxisValue(v);
      ctx.fillText(formattedVal, w-pad.r+6, y+4);
    }
  }

  // 日付ラインの表示
  if(showDateLine){
    visibleDates.forEach((d,i)=>{
      if(d && i % Math.ceil(visibleDates.length/6)===0){
        // 縦線を描画
        const x = getX(i);
        ctx.strokeStyle='#e5e7eb';
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(x, pad.t);
        ctx.lineTo(x, h-pad.b);
        ctx.stroke();
        // 日付ラベル
        ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--axisDark').trim() || '#6b7280';
        ctx.textAlign='center';
        ctx.fillText(d, x, h-6);
      }
    });
  }

  // ツールチップ用にオフセット情報も保存
  canvas.pointPositions = visibleDates.map((d,i)=>({
    x:getX(i),
    w:chartW/visibleDates.length,
    absIndex:visibleAbsIndices[i],
    date:d
  }));
  canvas.seriesOffsets = seriesOffsets;

  // 各系列を描画
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    const color = s.color || '#000000';
    const lineWidth = s.width || 2;

    // 有効なデータポイントを収集
    const validPoints = [];
    for(let i=0; i<visibleAbsIndices.length; i++){
      const absIdx = visibleAbsIndices[i];
      if(absIdx == null) continue;
      const v = getValue(s, absIdx, si);
      if(v == null || !Number.isFinite(v)) continue;
      const x = getX(i);
      const y = getY(v);
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      validPoints.push({x, y});
    }

    // 線を描画（有効なポイント間を連続して繋ぐ）
    if(validPoints.length >= 2){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(validPoints[0].x, validPoints[0].y);
      for(let i=1; i<validPoints.length; i++){
        ctx.lineTo(validPoints[i].x, validPoints[i].y);
      }
      ctx.stroke();
      ctx.restore();
    } else if(validPoints.length === 1){
      // 1点のみの場合は小さな円で表示
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(validPoints[0].x, validPoints[0].y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function formatAxisValue(v){
  const absV = Math.abs(v);
  if(absV >= 1e12){
    return (v / 1e12).toFixed(1) + "兆";
  } else if(absV >= 1e8){
    return (v / 1e8).toFixed(1) + "億";
  } else if(absV >= 1e4){
    return (v / 1e4).toFixed(0) + "万";
  } else {
    return v.toFixed(0);
  }
}

// 部門別売買動向用：千円単位→億円単位で表示
// 1億円 = 100,000千円（1e5）
// 1兆円 = 100,000,000千円（1e8）
function formatTseAxisValue(v){
  // vは千円単位
  const okuVal = v / 1e5; // 億円に変換
  const absOku = Math.abs(okuVal);

  if(absOku >= 10000){
    // 1兆以上：○兆○○○○億円
    const cho = Math.floor(okuVal / 10000);
    const oku = Math.abs(Math.round(okuVal % 10000));
    if(oku === 0){
      return cho + "兆円";
    }
    return cho + "兆" + oku + "億円";
  } else {
    // 1兆未満：○○億円
    return Math.round(okuVal) + "億円";
  }
}

function resizeCanvas(canvas){
  const rect=canvas.getBoundingClientRect();
  canvas.width=Math.floor(rect.width);
  canvas.height=Math.floor(rect.height);
}

/* ========= tooltip ========= */
function fmt(n){
  return (n!==null && n!==undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined,{maximumFractionDigits:2})
    : '-';
}
function showTooltipForCanvas(e, canvas, data){
  const pps = canvas.pointPositions;
  if(!pps || !data) return;

  const rect=canvas.getBoundingClientRect();
  const mouseX=e.clientX-rect.left;

  const p = pps.find(pp => mouseX >= pp.x - pp.w/2 && mouseX <= pp.x + pp.w/2);
  if(!p){
    tooltip.style.display='none';
    return;
  }
  const absIdx = p.absIndex;
  const date = p.date || (absIdx!=null ? data.dates[absIdx] : "") || "";
  const offsets = canvas.seriesOffsets || [];
  let html = `<strong>${date}</strong><br>`;
  for(let si=0; si<data.series.length; si++){
    const s = data.series[si];
    let val = (absIdx!=null ? s.values[absIdx] : null);
    // 累積データの場合はオフセット調整
    if(val != null && s.isCumulative && offsets[si] != null){
      val = val - offsets[si];
    }
    html += `<span style="color:${s.color}; font-weight:700;">${s.label}</span>: ${fmt(val)}<br>`;
  }
  tooltip.innerHTML = html;
  tooltip.style.display='block';

  let tx=e.clientX+14, ty=e.clientY+14;
  if(tx+260>window.innerWidth) tx-=280;
  tooltip.style.left=tx+'px';
  tooltip.style.top=ty+'px';
}

/* ========= interactions (shared) ========= */
function getBaseDates(){
  return tseDates.length > 0 ? tseDates : globalDates;
}

function onWheelZoom(e){
  e.preventDefault();
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;

  const shrink = (e.deltaY < 0);
  displayCount += (shrink ? -1 : +1);
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, baseDates.length));

  offsetX = 0;

  syncCountControls();
  updateTopChips();
  redrawAll();
}
function onMouseDown(e, canvas){
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;
  isDragging = true;
  dragCanvas = canvas;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}
function onMouseMove(e){
  const baseDates = getBaseDates();
  if(!baseDates || baseDates.length===0) return;

  if(isDragging){
    const canvas = dragCanvas || idxCanvas;
    const rect = canvas.getBoundingClientRect();
    const usableW = Math.max(1, rect.width - 120);
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, usableW / displayCount);
    const moveBars = diffX / ppc;

    const n = baseDates.length;
    const maxOffset = Math.max(0, n - displayCount);

    let newOffset = dragStartOffset + moveBars;
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = Math.round(newOffset);

    updateTopChips();
    redrawAll();
  }
}
function onMouseUp(){
  isDragging = false;
  dragCanvas = null;
  document.body.style.cursor = 'default';
}
function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display='none';
}

/* ========= redraw ========= */
function rebuildData(){
  // 指数データ
  idxData = buildIdxSeries(idxRows, idxKey, idxDates);
  idxData.dateIndex = buildDateIndex(idxDates);

  // 部門別データ
  tseData = buildTseSeries(tseRows, tseKeys, tseColors, tseDates, tseVisible);
  tseData.dateIndex = buildDateIndex(tseDates);

  renderLegend("idxLegend", idxData);
  renderLegend("tseLegend", tseData);

  // UIの状態を更新（差引累計がある場合は他を無効化）
  updateTseSelectionUI();
}

// 各チャート用の独立した表示範囲を計算
function getChartWindow(dates, baseDates){
  // baseDatesを基準に表示範囲を計算し、datesに適用
  const n = baseDates.length;
  const count = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - count);
  const localOffset = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
  const startRaw = n - count - localOffset;
  const endRaw = startRaw + count;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  // 基準となる日付範囲を取得
  const startDate = baseDates[start] || null;
  const endDate = baseDates[end - 1] || null;

  if(!startDate || !endDate || dates.length === 0){
    return { visibleDates: [], visibleAbsIndices: [] };
  }

  // datesから該当範囲の日付を抽出
  const filteredIndices = [];
  const filteredDates = [];
  for(let i = 0; i < dates.length; i++){
    const d = dates[i];
    if(d >= startDate && d <= endDate){
      filteredIndices.push(i);
      filteredDates.push(d);
    }
  }

  return { visibleDates: filteredDates, visibleAbsIndices: filteredIndices };
}

function redrawAll(){
  rebuildData(); // 累積計算のために毎回再構築

  // 部門別データがメイン: tseDatesを基準にする
  // 指数データはその範囲に合わせる
  const baseDates = tseDates.length > 0 ? tseDates : globalDates;

  // 部門別チャート: tseDatesを基準
  const tseWindow = getChartWindow(tseDates, baseDates);

  // 指数チャート: 同じ期間だがidxDatesで
  const idxWindow = getChartWindow(idxDates, baseDates);

  drawChartGeneric(idxCtx, idxCanvas, idxData, idxWindow.visibleDates, idxWindow.visibleAbsIndices, false);
  drawChartGeneric(tseCtx, tseCanvas, tseData, tseWindow.visibleDates, tseWindow.visibleAbsIndices, true);
}

/* ========= select UI ========= */
function updateTseSelectionUI(){
  // 差引累計が1つでも選択・表示されているかチェック
  const hasCumulative = tseKeys.some((k, i) => k && k.endsWith("_差引累計") && tseVisible[i]);

  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    const sel = document.getElementById(`tseSel${i+1}`);
    const colorPicker = document.getElementById(`tseColor${i+1}`);
    const checkbox = document.getElementById(`tseCheck${i+1}`);
    const selDiv = sel ? sel.closest('.sel') : null;

    if(!sel || !checkbox || !selDiv) continue;

    const k = tseKeys[i];
    const isCumulative = k && k.endsWith("_差引累計");

    // チェックボックスの状態を更新
    checkbox.checked = tseVisible[i];

    // 差引累計がある場合、差引累計以外は無効化表示
    if(hasCumulative && k && !isCumulative){
      selDiv.classList.add('disabled');
    } else {
      selDiv.classList.remove('disabled');
    }
  }
}

function fillIdxSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "— 選択してください —";
  selectEl.appendChild(optEmpty);
  for(const n of names){
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = n;
    selectEl.appendChild(opt);
  }
  selectEl.value = current || "";
}

// 表示名からvalue（キー名）を抽出する関数
function extractKeyFromDisplayName(displayName){
  // ├─、└─、　├─、　└─などのプレフィックスを除去
  return displayName.replace(/^[├└　 ─]+/, '').trim();
}

function fillTseSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "— 選択 —";
  selectEl.appendChild(optEmpty);

  let currentOptGroup = null;

  for(const n of names){
    const trimmed = n.trim();

    // セパレータ行（ー差引累計ー、ー個別項目ー）はoptgroupとして扱う
    if(trimmed.startsWith("ー") && trimmed.endsWith("ー")){
      currentOptGroup = document.createElement("optgroup");
      currentOptGroup.label = trimmed;
      selectEl.appendChild(currentOptGroup);
      continue;
    }

    const opt = document.createElement("option");
    const keyName = extractKeyFromDisplayName(n);
    opt.value = keyName;
    opt.textContent = n; // プレフィックス付きの表示名
    opt.dataset.fullName = n; // 元のプレフィックス付き名前を保存
    opt.dataset.shortName = keyName; // プレフィックスなしの名前を保存

    if(currentOptGroup){
      currentOptGroup.appendChild(opt);
    } else {
      selectEl.appendChild(opt);
    }
  }

  selectEl.value = current || "";
  // 選択後の表示をプレフィックスなしに更新
  updateSelectDisplay(selectEl);
}

// 選択されたオプションの表示をプレフィックスなしに変更する
function updateSelectDisplay(selectEl){
  const selectedOpt = selectEl.options[selectEl.selectedIndex];
  if(selectedOpt && selectedOpt.dataset.shortName){
    selectedOpt.textContent = selectedOpt.dataset.shortName;
  }
}

// プルダウンを開くときに全オプションの表示をプレフィックス付きに戻す
function restoreSelectDisplay(selectEl){
  for(const opt of selectEl.options){
    if(opt.dataset.fullName){
      opt.textContent = opt.dataset.fullName;
    }
  }
}

function bindSelects(){
  // 指数セレクト（1つのみ）
  const idxSel = document.getElementById("idxSel1");
  fillIdxSelect(idxSel, idxAvail, idxKey);
  idxSel.addEventListener("change", ()=>{
    idxKey = idxSel.value || "";
    try{ localStorage.setItem("idxKey_v4", idxKey); }catch(e){}
    redrawAll();
  });

  // 部門別セレクト（8つ）
  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    const sel = document.getElementById(`tseSel${i+1}`);
    const colorPicker = document.getElementById(`tseColor${i+1}`);
    const checkbox = document.getElementById(`tseCheck${i+1}`);

    fillTseSelect(sel, tseAvail, tseKeys[i]);
    colorPicker.value = tseColors[i];
    checkbox.checked = tseVisible[i];

    // プルダウンを開くときにプレフィックス付きの表示に戻す
    sel.addEventListener("focus", ()=>{
      restoreSelectDisplay(sel);
    });

    // プルダウンを閉じるときにプレフィックスなしの表示に変更
    sel.addEventListener("blur", ()=>{
      updateSelectDisplay(sel);
    });

    sel.addEventListener("change", ()=>{
      tseKeys[i] = sel.value || "";
      // 何かを選択したら表示をONにする
      if(tseKeys[i]) tseVisible[i] = true;
      try{ localStorage.setItem("tseKeys_v3", JSON.stringify(tseKeys)); }catch(e){}
      try{ localStorage.setItem("tseVisible_v2", JSON.stringify(tseVisible)); }catch(e){}
      // 選択後の表示をプレフィックスなしに更新
      updateSelectDisplay(sel);
      redrawAll();
    });

    colorPicker.addEventListener("input", ()=>{
      tseColors[i] = colorPicker.value;
      try{ localStorage.setItem("tseColors_v2", JSON.stringify(tseColors)); }catch(e){}
      redrawAll();
    });

    checkbox.addEventListener("change", ()=>{
      tseVisible[i] = checkbox.checked;
      try{ localStorage.setItem("tseVisible_v2", JSON.stringify(tseVisible)); }catch(e){}
      redrawAll();
    });
  }
}

/* ========= main load ========= */
async function autoLoad(){
  const statusEl = document.getElementById("status");

  // 指数データ
  idxRows = [];
  try{
    statusEl.textContent = "PtoCSV_long.csv 読み込み中…";
    const txt1 = await fetchTextAutoEncoding("./PtoCSV_long.csv");
    idxRows = parsePtoCsvToLong(txt1);
  }catch(e){
    console.warn(e);
    statusEl.textContent = `PtoCSV_long.csv 読込エラー: ${e.message}`;
  }

  // 部門別データ
  tseRows = [];
  try{
    statusEl.textContent += " / TSEPrime.csv 読み込み中…";
    const txt2 = await fetchTextAutoEncoding("./data/TSEPrime.csv");
    tseRows = parseTsePrimeToLong(txt2);
  }catch(e){
    console.warn(e);
    statusEl.textContent += ` / TSEPrime 読込エラー: ${e.message}`;
  }

  // プルダウン用リスト
  const idxNamesFromData = uniqSorted(idxRows.map(r => r.name));
  const tseNamesFromData = uniqSorted(tseRows.map(r => r.name));

  let idxList = null;
  let tseList = null;
  try{ idxList = await loadNameList("./list.csv"); }catch(e){ console.warn(e); }
  try{ tseList = await loadNameList("./bumonlist.csv"); }catch(e){ console.warn(e); }

  idxAvail = (idxList ? idxList.filter(n => idxNamesFromData.includes(n)) : idxNamesFromData);
  if(idxAvail.length === 0) idxAvail = idxNamesFromData;

  // 部門別リストのフィルタリング（表示順リストを尊重）
  if(tseList){
    tseAvail = tseList.filter(n => {
      const trimmed = n.trim();
      // セパレータ行は常に含める
      if(trimmed.startsWith("ー") && trimmed.endsWith("ー")) return true;
      // キー名を抽出
      const keyName = extractKeyFromDisplayName(n);
      // 合成項目（金融_差引累計、法人_差引累計）は常に含める
      if(COMPOSITE_FIELDS.hasOwnProperty(keyName)) return true;
      // 差引累計項目の場合、ベースとなる差引がデータに存在するか確認
      if(keyName.endsWith("_差引累計")){
        const baseKey = keyName.replace("_差引累計", "_差引");
        return tseNamesFromData.includes(baseKey);
      }
      // 通常の項目はデータに存在するか確認
      return tseNamesFromData.includes(keyName);
    });
  } else {
    tseAvail = tseNamesFromData;
  }
  if(tseAvail.length === 0) tseAvail = tseNamesFromData;

  // 日付軸
  idxDates = buildDateList(idxRows);
  tseDates = buildDateList(tseRows);
  globalDates = buildGlobalDates(idxRows, tseRows);

  // restore selections
  try{
    const raw = localStorage.getItem("idxKey_v4");
    if(raw && idxAvail.includes(raw)){
      idxKey = raw;
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseKeys_v3");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseKeys = new Array(TSE_SELECTION_COUNT).fill("").map((_, i)=> arr[i] || "");
      }
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseColors_v2");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseColors = new Array(TSE_SELECTION_COUNT).fill("").map((_, i)=> arr[i] || DEFAULT_COLORS[i]);
      }
    }
  }catch(e){}

  try{
    const raw = localStorage.getItem("tseVisible_v2");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)){
        tseVisible = new Array(TSE_SELECTION_COUNT).fill(true).map((_, i)=> arr[i] !== false);
      }
    }
  }catch(e){}

  // デフォルト値設定
  // 株価指数のデフォルト: TOPIX終値
  if(!idxKey){
    if(idxAvail.includes("TOPIX終値")){
      idxKey = "TOPIX終値";
    } else if(idxAvail[0]){
      idxKey = idxAvail[0];
    }
  }

  // 部門別のデフォルト：自己計、個人、海外投資家、投資信託、金融、法人の差引累計
  const defaultTseKeys = [
    "自己計_差引累計",
    "個人_差引累計",
    "海外投資家_差引累計",
    "投資信託_差引累計",
    "金融_差引累計",
    "法人_差引累計",
    "",
    ""
  ];
  for(let i=0; i<TSE_SELECTION_COUNT; i++){
    if(!tseKeys[i] && defaultTseKeys[i]) {
      const key = defaultTseKeys[i];
      // 合成項目（金融_差引累計、法人_差引累計）の場合は直接設定
      if(COMPOSITE_FIELDS.hasOwnProperty(key)){
        tseKeys[i] = key;
      } else {
        // 累計の場合、ベースとなる差引が存在するかチェック
        const baseKey = key.replace("_差引累計", "_差引");
        const tseNamesFromData = uniqSorted(tseRows.map(r => r.name));
        if(tseNamesFromData.includes(baseKey)){
          tseKeys[i] = key;
        }
      }
    }
  }

  const baseDatesLoaded = tseDates.length > 0 ? tseDates : globalDates;
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, baseDatesLoaded.length || displayCount));
  offsetX = 0;
  syncCountControls();
  updateTopChips();

  bindSelects();
  redrawAll();

  statusEl.textContent =
    `ロード完了: 日付 ${globalDates.length.toLocaleString()} / 指数行 ${idxRows.length.toLocaleString()} / 部門行 ${tseRows.length.toLocaleString()}`;
}

/* ========= init ========= */
function init(){
  idxCanvas = document.getElementById("idxChart");
  tseCanvas = document.getElementById("tseChart");
  idxCtx = idxCanvas.getContext("2d");
  tseCtx = tseCanvas.getContext("2d");
  tooltip = document.getElementById("tooltip");

  bindControls();
  const doResize = ()=>{
    resizeCanvas(idxCanvas);
    resizeCanvas(tseCanvas);
    redrawAll();
  };
  window.addEventListener("resize", doResize);
  doResize();

  for(const c of [idxCanvas, tseCanvas]){
    c.addEventListener("wheel", onWheelZoom, {passive:false});
    c.addEventListener("mousedown", (e)=>onMouseDown(e, c));
    c.addEventListener("mousemove", (e)=>{
      onMouseMove(e);
      if(!isDragging){
        const data = (c === idxCanvas ? idxData : tseData);
        showTooltipForCanvas(e, c, data);
      }
    });
    c.addEventListener("mouseup", onMouseUp);
    c.addEventListener("mouseleave", onMouseLeave);
  }
  window.addEventListener("mouseup", onMouseUp);

  // 部門別プルダウンの表示/非表示トグル
  const tseToggleBtn = document.getElementById("tseToggleBtn");
  const tseSelContainer = document.getElementById("tseSelContainer");
  tseToggleBtn.addEventListener("click", ()=>{
    const isHidden = tseSelContainer.classList.toggle("hidden");
    tseToggleBtn.textContent = isHidden ? "＋" : "－";
  });

  autoLoad().catch(err=>{
    console.error(err);
    document.getElementById("status").textContent = `エラー: ${err.message}`;
  });
}
window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
