<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Index + TSEPrime (2 charts)</title>
  <style>
    :root{
      --bg:#f5f5f7;
      --card:#ffffff;
      --text:#1f2328;
      --muted:#6b7280;
      --axisDark:#6b7280;
      --line:#e5e7eb;
      --chip:#f3f4f6;
      --shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    body{
      margin:0; padding:16px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg); color:var(--text);
    }
    .wrap{ width:100%; margin:0 auto; }
    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:14px; box-shadow:var(--shadow);
      padding:14px 16px;
      max-width:1240px;
      margin:0 auto;
    }
    .header{
      display:flex; align-items:baseline; gap:12px; flex-wrap:wrap;
    }
    .header h1{ margin:0; font-size:16px; letter-spacing:0.2px; }
    .sub{ font-size:12px; color:var(--muted); }
    .headerRight{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .rows{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

    .controls{
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .group{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fafafa;
      border-radius:12px;
    }
    .label{ font-weight:700; font-size:12px; color:#374151; }
    input[type="range"]{ width:260px; }
    input[type="number"]{
      width:86px; padding:6px 8px;
      border:1px solid #cfd4dc; border-radius:10px;
      background:#fff; font-size:13px; text-align:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      background:var(--chip);
      border-radius:999px;
      font-size:12px; color:#111827;
      white-space:nowrap;
    }
    .chip .muted{ color:var(--muted); }

    .grid2{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .chartCard{ border:1px solid var(--line); border-radius:12px; background:#fff; overflow:hidden; }
    .chartHead{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background:#fafafa;
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    .chartTitle{ font-weight:700; font-size:13px; color:#111827; margin-right:auto; }

    .legend{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .legend-item{ display:flex; align-items:center; gap:6px; font-size:12px; color:#374151; }
    .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.15); }

    /* Pull-down area (explicit, always visible) */
    .selRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      width:100%;
    }
    .sel{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:12px;
    }
    .sel .slot{
      width:18px;
      text-align:right;
      font-size:12px;
      color:var(--muted);
      flex:0 0 auto;
    }
    select{
      min-width:240px;
      padding:6px 8px;
      border:1px solid #cfd4dc;
      border-radius:10px;
      background:#fff;
      font-size:13px;
    }

    .canvasBox{ position:relative; background:#fff; }
    canvas{ display:block; width:100%; cursor:crosshair; }
    #idxChart{ height:260px; }
    #tseChart{ height:520px; } /* 以前の半分（780 -> 520） */

    .tooltip{
      position:fixed;
      background:rgba(255,255,255,0.98);
      border:1px solid #9ca3af; padding:8px 10px; border-radius:10px;
      font-size:12px; pointer-events:none; display:none;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:1000; line-height:1.45; white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <h1>Charts: Index (PtoCSV) + 部門別売買動向 (TSEPrime)</h1>
        <span class="sub" id="status">読込中…</span>
        <div class="headerRight">
          <span class="chip" id="latestChip"><span class="muted">最新</span> -</span>
          <span class="chip" id="viewChip"><span class="muted">表示範囲</span> -</span>
        </div>
      </div>

      <div class="rows">
        <div class="controls">
          <div class="group">
            <div class="label">表示本数</div>
            <input id="countRange" type="range" min="10" max="700" step="1" value="200">
            <input id="countNum" type="number" min="10" max="700" step="1" value="200">
          </div>
          <div class="group">
            <div class="label">操作</div>
            <span class="chip"><span class="muted">ホイール</span> 拡大/縮小</span>
            <span class="chip"><span class="muted">ドラッグ</span> 横スクロール</span>
          </div>
        </div>

        <div class="grid2">
          <!-- ===== Index chart (1 pull-down) ===== -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">株価指数（PtoCSV.csv / list.csv）</div>
              <div class="legend" id="idxLegend"></div>
              <div class="selRow" id="idxSelRow">
                <div class="sel">
                  <div class="slot">1</div>
                  <select id="idxSel1"></select>
                </div>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="idxChart"></canvas>
            </div>
          </div>

          <!-- ===== TSE chart (5 pull-downs) ===== -->
          <div class="chartCard">
            <div class="chartHead">
              <div class="chartTitle">部門別売買動向（TSEPrime.csv / bumonlist.csv）</div>
              <div class="legend" id="tseLegend"></div>
              <div class="selRow" id="tseSelRow">
                <div class="sel"><div class="slot">1</div><select id="tseSel1"></select></div>
                <div class="sel"><div class="slot">2</div><select id="tseSel2"></select></div>
                <div class="sel"><div class="slot">3</div><select id="tseSel3"></select></div>
                <div class="sel"><div class="slot">4</div><select id="tseSel4"></select></div>
                <div class="sel"><div class="slot">5</div><select id="tseSel5"></select></div>
              </div>
            </div>
            <div class="canvasBox">
              <canvas id="tseChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
  </div>

<script>
/* ========= colors ========= */
const COLOR_PALETTE = [
  { hex: "#FF4B00" }, { hex: "#005AFF" }, { hex: "#03AF7A" },
  { hex: "#4DC4FF" }, { hex: "#F6AA00" }, { hex: "#FFF100" },
  { hex: "#000000" }, { hex: "#990099" }, { hex: "#84919E" }
];
const INITIAL_COLORS = ["#FF4B00","#005AFF","#03AF7A","#4DC4FF","#F6AA00","#FFF100"];
const MAX_DISPLAY = 700;

/* ========= TSEPrime: 英語列名 -> 日本語表示名 ========= */
const TSEPRIME_FIELD_MAP = {
  PropSell: "自己計_売",   PropBuy:"自己計_買",   PropTot:"自己計_合計",   PropBal:"自己計_差引",
  BrkSell: "委託計_売",    BrkBuy:"委託計_買",    BrkTot:"委託計_合計",    BrkBal:"委託計_差引",
  TotSell: "総計_売",      TotBuy:"総計_買",      TotTot:"総計_合計",      TotBal:"総計_差引",
  IndSell: "個人_売",      IndBuy:"個人_買",      IndTot:"個人_合計",      IndBal:"個人_差引",
  FrgnSell:"海外投資家_売",FrgnBuy:"海外投資家_買",FrgnTot:"海外投資家_合計",FrgnBal:"海外投資家_差引",
  SecCoSell:"証券会社_売", SecCoBuy:"証券会社_買", SecCoTot:"証券会社_合計", SecCoBal:"証券会社_差引",
  InvTrSell:"投資信託_売", InvTrBuy:"投資信託_買", InvTrTot:"投資信託_合計", InvTrBal:"投資信託_差引",
  BusCoSell:"事業法人_売", BusCoBuy:"事業法人_買", BusCoTot:"事業法人_合計", BusCoBal:"事業法人_差引",
  OthCoSell:"その他法人_売",OthCoBuy:"その他法人_買",OthCoTot:"その他法人_合計",OthCoBal:"その他法人_差引",
  InsCoSell:"生保・損保_売",InsCoBuy:"生保・損保_買",InsCoTot:"生保・損保_合計",InsCoBal:"生保・損保_差引",
  BankSell:"都銀・地銀等_売",BankBuy:"都銀・地銀等_買",BankTot:"都銀・地銀等_合計",BankBal:"都銀・地銀等_差引",
  TrstBnkSell:"信託銀行_売",TrstBnkBuy:"信託銀行_買",TrstBnkTot:"信託銀行_合計",TrstBnkBal:"信託銀行_差引",
  OthFinSell:"その他金融機関_売",OthFinBuy:"その他金融機関_買",OthFinTot:"その他金融機関_合計",OthFinBal:"その他金融機関_差引"
};

/* ========= state ========= */
let idxRows = [];   // {date,name,value}
let tseRows = [];   // {date,name,value}
let globalDates = [];

let displayCount = 200;
let offsetX = 0; // shared

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;
let dragCanvas = null;

let idxCanvas, idxCtx, tseCanvas, tseCtx, tooltip;

let idxAvail = [];
let tseAvail = [];

let idxKey = "";           // 1 item
let tseKeys = ["","","","",""]; // 5 items

let idxData = null;
let tseData = null;

/* ========= helpers ========= */
function toNum(s){
  if(s==null) return NaN;
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim());
}
function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}
function uniqSorted(arr){
  const set = new Set(arr);
  const out = Array.from(set);
  out.sort((a,b)=>String(a).localeCompare(String(b)));
  return out;
}
function buildGlobalDates(idxRows, tseRows){
  const set = new Set();
  for(const r of idxRows){ if(r && r.date) set.add(r.date); }
  for(const r of tseRows){ if(r && r.date) set.add(r.date); }
  const arr = Array.from(set);
  arr.sort((a,b)=>{
    const ta=new Date(a).getTime(), tb=new Date(b).getTime();
    if(!Number.isNaN(ta) && !Number.isNaN(tb)) return ta-tb;
    return String(a).localeCompare(String(b));
  });
  return arr;
}
function clampView(){
  const n = globalDates.length;
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, n || 10));
  const maxOffset = Math.max(0, n - displayCount);
  offsetX = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
}
function getVisibleWindow(){
  clampView();
  const n = globalDates.length;
  const startRaw = n - displayCount - offsetX;
  const endRaw = startRaw + displayCount;
  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realDates = (start < end) ? globalDates.slice(start, end) : [];
  const realLen = realDates.length;

  const padN = displayCount - realLen;
  const pads = new Array(Math.max(0,padN)).fill("");

  const visibleDates = pads.concat(realDates);
  const visibleAbsIndices = new Array(Math.max(0,padN)).fill(null).concat(
    Array.from({length: realLen}, (_,i)=> start + i)
  );
  return { visibleDates, visibleAbsIndices };
}
function updateTopChips(){
  const latestEl = document.getElementById("latestChip");
  const viewEl = document.getElementById("viewChip");
  if(!globalDates || globalDates.length===0){
    latestEl.innerHTML = `<span class="muted">最新</span> -`;
    viewEl.innerHTML = `<span class="muted">表示範囲</span> -`;
    return;
  }
  latestEl.innerHTML = `<span class="muted">最新</span> ${globalDates[globalDates.length-1]}`;

  const { visibleDates } = getVisibleWindow();
  let startDate=null, endDate=null;
  for(let i=0;i<visibleDates.length;i++){ if(visibleDates[i]){ startDate=visibleDates[i]; break; } }
  for(let i=visibleDates.length-1;i>=0;i--){ if(visibleDates[i]){ endDate=visibleDates[i]; break; } }
  viewEl.innerHTML = `<span class="muted">表示範囲</span> ${startDate&&endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}
function syncCountControls(){
  const r=document.getElementById('countRange');
  const n=document.getElementById('countNum');
  r.max=String(MAX_DISPLAY);
  n.max=String(MAX_DISPLAY);
  r.value=String(displayCount);
  n.value=String(displayCount);
}
function bindControls(){
  const countRange=document.getElementById('countRange');
  const countNum=document.getElementById('countNum');

  const setCount=(v)=>{
    const nn=Number(v);
    if(!Number.isFinite(nn)) return;
    displayCount=Math.max(10, Math.min(Math.round(nn), MAX_DISPLAY, globalDates.length||MAX_DISPLAY));
    offsetX=0;
    countRange.value=String(displayCount);
    countNum.value=String(displayCount);
    updateTopChips();
    redrawAll();
  };

  countRange.addEventListener('input', ()=>setCount(countRange.value));
  countNum.addEventListener('change', ()=>setCount(countNum.value));
}

/* ========= parsers ========= */
function parsePtoCsvToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("PtoCSV.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(s=>s.replace(/\r/g,'').trim());

  const idxDate=header.indexOf("日付");
  const idxName=header.indexOf("商品名");
  const idxVal=header.indexOf("数値");
  if(idxDate<0||idxName<0||idxVal<0) throw new Error("PtoCSV.csv: 必須列(日付, 商品名, 数値)が見つかりません");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;
    const date=(cols[idxDate]||"").trim();
    const name=(cols[idxName]||"").trim();
    const value=toNum(cols[idxVal]);
    if(!date || !name || Number.isNaN(value)) continue;
    rows.push({date, name, value});
  }
  return rows;
}

function parseTsePrimeToLong(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("TSEPrime.csv: データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(s=>s.replace(/\r/g,'').trim());

  const idxPubDate=header.indexOf("PubDate");
  const idxSection=header.indexOf("Section");
  if(idxPubDate<0) throw new Error("TSEPrime.csv: 必須列(PubDate)が見つかりません");
  if(idxSection<0) throw new Error("TSEPrime.csv: 必須列(Section)が見つかりません");

  const fieldDefs = Object.entries(TSEPRIME_FIELD_MAP)
    .map(([en, jp]) => ({ jp, idx: header.indexOf(en) }))
    .filter(x => x.idx >= 0);

  if(fieldDefs.length===0) throw new Error("TSEPrime.csv: 数値列が見つかりません（Field map 不一致）");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;

    const section=(cols[idxSection]||"").trim();
    if(section!=="TSEPrime") continue;

    const date=(cols[idxPubDate]||"").trim();
    if(!date) continue;

    for(const f of fieldDefs){
      const value=toNum(cols[f.idx]);
      if(Number.isNaN(value)) continue;
      rows.push({date, name: f.jp, value});
    }
  }
  return rows;
}

/* ========= list loaders ========= */
async function loadNameList(filename){
  async function fetchText(decoderName){
    const res = await fetch(filename, {cache:'no-store'});
    if(!res.ok) return null;
    const buf = await res.arrayBuffer();
    const dec = new TextDecoder(decoderName, {fatal:false});
    return dec.decode(buf);
  }
  function parseToNames(text){
    if(!text) return null;
    const lines = text.split(/\r?\n/);
    const out = [];
    for(const raw of lines){
      let line = String(raw||"");
      line = line.replace(/^\uFEFF/, "").trim();
      if(!line || line.startsWith('#')) continue;
      const first = line.split(/\t|,/)[0].replace(/^"+|"+$/g,'').trim();
      if(first) out.push(first);
    }
    const seen = new Set();
    const uniq = [];
    for(const n of out){
      if(seen.has(n)) continue;
      seen.add(n);
      uniq.push(n);
    }
    return uniq.length ? uniq : null;
  }

  const tUtf8 = await fetchText('utf-8');
  const nUtf8 = parseToNames(tUtf8);

  const tSjis = await fetchText('shift-jis');
  const nSjis = parseToNames(tSjis);

  if(!nUtf8 && !nSjis) return null;
  if(nUtf8 && !nSjis) return nUtf8;
  if(!nUtf8 && nSjis) return nSjis;
  return (nSjis.length > nUtf8.length ? nSjis : nUtf8);
}

/* ========= series building ========= */
function buildOneSeries(rows, key, color){
  const map = new Map();
  for(const r of rows){ if(r.name===key) map.set(r.date, r.value); }
  const values = globalDates.map(d => (map.has(d) ? map.get(d) : null));
  return { label: key, color, width: 2, values };
}
function buildMultiSeries(rows, keys){
  const series = [];
  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    if(!k) continue;
    series.push(buildOneSeries(rows, k, INITIAL_COLORS[i] || COLOR_PALETTE[i % COLOR_PALETTE.length].hex));
  }
  return { dates: globalDates, series };
}

/* ========= draw ========= */
function renderLegend(elId, data){
  const box = document.getElementById(elId);
  if(!box) return;
  box.innerHTML = '';
  if(!data || !data.series || data.series.length===0) return;
  for(const s of data.series){
    const item = document.createElement('div');
    item.className = 'legend-item';
    const sw = document.createElement('span');
    sw.className = 'swatch';
    sw.style.background = s.color;
    item.appendChild(sw);
    const txt = document.createElement('span');
    txt.textContent = s.label;
    item.appendChild(txt);
    box.appendChild(item);
  }
}

function drawChartGeneric(ctx, canvas, data, visibleDates, visibleAbsIndices){
  const w=canvas.width, h=canvas.height;
  const pad={t:14,b:28,l:12,r:74};
  const chartW=w-pad.l-pad.r;
  const chartH=h-pad.t-pad.b;

  ctx.clearRect(0,0,w,h);

  if(!data || !data.series || data.series.length===0 || !data.dates || data.dates.length===0){
    ctx.fillStyle='#6b7280';
    ctx.textAlign='center';
    ctx.fillText("No Data", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  let minV=Infinity, maxV=-Infinity;
  for(const s of data.series){
    for(const absIdx of visibleAbsIndices){
      if(absIdx==null) continue;
      const v=s.values[absIdx];
      if(v==null || Number.isNaN(v)) continue;
      minV=Math.min(minV,v); maxV=Math.max(maxV,v);
    }
  }
  if(minV===Infinity){
    ctx.fillStyle='#6b7280'; ctx.textAlign='center'; ctx.fillText("No Data", w/2, h/2);
    canvas.pointPositions = [];
    return;
  }

  const range=(maxV-minV)||1;
  minV -= range*0.06;
  maxV += range*0.06;

  const scaleY=chartH/(maxV-minV);
  const getX=(i)=>pad.l+(i+0.5)*(chartW/visibleDates.length);
  const getY=(val)=>pad.t+chartH-(val-minV)*scaleY;

  // grid + y labels
  ctx.strokeStyle='#eef0f3'; ctx.lineWidth=1;
  const gridSteps=5;
  for(let i=0;i<=gridSteps;i++){
    const y=pad.t+(chartH*i/gridSteps);
    const v=maxV-(maxV-minV)*(i/gridSteps);
    ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
    ctx.fillStyle='#9aa1ab'; ctx.textAlign='left';
    ctx.fillText(String(Math.round(v)), w-pad.r+6, y+4);
  }

  // x labels
  visibleDates.forEach((d,i)=>{
    if(d && i % Math.ceil(visibleDates.length/6)===0){
      ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--axisDark').trim() || '#6b7280';
      ctx.textAlign='center';
      ctx.fillText(d, getX(i), h-6);
    }
  });

  // tooltip positions
  canvas.pointPositions = visibleDates.map((d,i)=>({
    x:getX(i),
    w:chartW/visibleDates.length,
    absIndex:visibleAbsIndices[i],
    date:d
  }));

  // lines
  for(const s of data.series){
    ctx.strokeStyle=s.color;
    ctx.lineWidth=s.width;
    ctx.beginPath();
    let moved=false;
    visibleAbsIndices.forEach((absIdx,i)=>{
      if(absIdx==null){ moved=false; return; }
      const v=s.values[absIdx];
      if(v==null || Number.isNaN(v)){ moved=false; return; }
      const x=getX(i), y=getY(v);
      if(!moved){ ctx.moveTo(x,y); moved=true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }
}

function resizeCanvas(canvas){
  const rect=canvas.getBoundingClientRect();
  canvas.width=Math.floor(rect.width);
  canvas.height=Math.floor(rect.height);
}

/* ========= tooltip ========= */
function fmt(n){
  return (n!==null && n!==undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined,{maximumFractionDigits:2})
    : '-';
}
function showTooltipForCanvas(e, canvas, data){
  const pps = canvas.pointPositions;
  if(!pps || !data) return;

  const rect=canvas.getBoundingClientRect();
  const mouseX=e.clientX-rect.left;

  const p = pps.find(pp => mouseX >= pp.x - pp.w/2 && mouseX <= pp.x + pp.w/2);
  if(!p){
    tooltip.style.display='none';
    return;
  }
  const absIdx = p.absIndex;
  if(absIdx==null){
    tooltip.style.display='none';
    return;
  }

  const date = globalDates[absIdx] || p.date || "";
  let html = `<strong>${date}</strong><br>`;
  for(const s of data.series){
    html += `<span style="color:${s.color}; font-weight:700;">${s.label}</span>: ${fmt(s.values[absIdx])}<br>`;
  }
  tooltip.innerHTML = html;
  tooltip.style.display='block';

  let tx=e.clientX+14, ty=e.clientY+14;
  if(tx+260>window.innerWidth) tx-=280;
  tooltip.style.left=tx+'px';
  tooltip.style.top=ty+'px';
}

/* ========= interactions (shared) ========= */
function onWheelZoom(e){
  e.preventDefault();
  if(!globalDates || globalDates.length===0) return;

  const shrink = (e.deltaY < 0);
  displayCount += (shrink ? -1 : +1);
  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, globalDates.length));

  offsetX = 0;

  syncCountControls();
  updateTopChips();
  redrawAll();
}
function onMouseDown(e, canvas){
  if(!globalDates || globalDates.length===0) return;
  isDragging = true;
  dragCanvas = canvas;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}
function onMouseMove(e){
  if(!globalDates || globalDates.length===0) return;

  if(isDragging){
    const canvas = dragCanvas || idxCanvas;
    const rect = canvas.getBoundingClientRect();
    const usableW = Math.max(1, rect.width - 120);
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, usableW / displayCount);
    const moveBars = diffX / ppc;

    const n = globalDates.length;
    const maxOffset = Math.max(0, n - displayCount);

    let newOffset = dragStartOffset + moveBars;
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = Math.round(newOffset);

    updateTopChips();
    redrawAll();
  }
}
function onMouseUp(){
  isDragging = false;
  dragCanvas = null;
  document.body.style.cursor = 'default';
}
function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display='none';
}

/* ========= redraw ========= */
function rebuildData(){
  idxData = { dates: globalDates, series: (idxKey ? [buildOneSeries(idxRows, idxKey, INITIAL_COLORS[0])] : []) };
  tseData = buildMultiSeries(tseRows, tseKeys);
  renderLegend("idxLegend", idxData);
  renderLegend("tseLegend", tseData);
}
function redrawAll(){
  const { visibleDates, visibleAbsIndices } = getVisibleWindow();
  drawChartGeneric(idxCtx, idxCanvas, idxData, visibleDates, visibleAbsIndices);
  drawChartGeneric(tseCtx, tseCanvas, tseData, visibleDates, visibleAbsIndices);
}

/* ========= select UI ========= */
function fillSelect(selectEl, names, current){
  selectEl.innerHTML = "";
  const optEmpty = document.createElement("option");
  optEmpty.value = "";
  optEmpty.textContent = "—";
  selectEl.appendChild(optEmpty);
  for(const n of names){
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = n;
    selectEl.appendChild(opt);
  }
  selectEl.value = current || "";
}

function bindSelects(){
  const idxSel1 = document.getElementById("idxSel1");
  fillSelect(idxSel1, idxAvail, idxKey);
  idxSel1.addEventListener("change", ()=>{
    idxKey = idxSel1.value || "";
    try{ localStorage.setItem("idxKey_v1", idxKey); }catch(e){}
    rebuildData(); redrawAll();
  });

  for(let i=0;i<5;i++){
    const el = document.getElementById(`tseSel${i+1}`);
    fillSelect(el, tseAvail, tseKeys[i]);
    el.addEventListener("change", ()=>{
      tseKeys[i] = el.value || "";
      try{ localStorage.setItem("tseKeys_v1", JSON.stringify(tseKeys)); }catch(e){}
      rebuildData(); redrawAll();
    });
  }
}

/* ========= main load ========= */
async function autoLoad(){
  const statusEl = document.getElementById("status");


  // 2) 指数データ（固定: ./PtoCSV_long.csv）
  idxRows = [];
  try{
    statusEl.textContent = "PtoCSV_long.csv 読み込み中…";
    const res1 = await fetch("./PtoCSV_long.csv", {cache:"no-store"});
    if(!res1.ok) throw new Error(`PtoCSV_long.csv fetch失敗: ${res1.status} ${res1.statusText}`);
    const txt1 = await res1.text();
    idxRows = parsePtoCsvToLong(txt1); // long形式ならこのパーサでOK
  }catch(e){
    console.warn(e);
    statusEl.textContent = `PtoCSV_long.csv 読込エラー: ${e.message}`;
  }

  // 3) 部門別データ（固定: ./data/TSEPrime.csv）
  tseRows = [];
  try{
    statusEl.textContent += " / TSEPrime.csv 読み込み中…";
    const res2 = await fetch("./data/TSEPrime.csv", {cache:"no-store"});
    if(!res2.ok) throw new Error(`data/TSEPrime.csv fetch失敗: ${res2.status} ${res2.statusText}`);
    const txt2 = await res2.text();
    tseRows = parseTsePrimeToLong(txt2);
  }catch(e){
    console.warn(e);
    statusEl.textContent += ` / TSEPrime 読込エラー: ${e.message}`;
  }
  
  // restore last selections
  try{
    const k = localStorage.getItem("idxKey_v1");
    if(k && idxAvail.includes(k)) idxKey = k;
  }catch(e){}
  try{
    const raw = localStorage.getItem("tseKeys_v1");
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr) && arr.length===5){
        tseKeys = arr.map(x => (tseAvail.includes(x) ? x : ""));
      }
    }
  }catch(e){}

  // if empty, pick defaults
  if(!idxKey && idxAvail[0]) idxKey = idxAvail[0];
  for(let i=0;i<5;i++){
    if(!tseKeys[i] && tseAvail[i]) tseKeys[i] = tseAvail[i];
  }

  displayCount = Math.max(10, Math.min(displayCount, MAX_DISPLAY, globalDates.length || displayCount));
  offsetX = 0;
  syncCountControls();
  updateTopChips();

  bindSelects();
  rebuildData();
  redrawAll();

  statusEl.textContent = `ロード完了: 日付 ${globalDates.length.toLocaleString()} / 指数行 ${idxRows.length.toLocaleString()} / 部門行 ${tseRows.length.toLocaleString()}`;
}

/* ========= init ========= */
function init(){
  idxCanvas = document.getElementById("idxChart");
  tseCanvas = document.getElementById("tseChart");
  idxCtx = idxCanvas.getContext("2d");
  tseCtx = tseCanvas.getContext("2d");
  tooltip = document.getElementById("tooltip");

  bindControls();
  const doResize = ()=>{
    resizeCanvas(idxCanvas);
    resizeCanvas(tseCanvas);
    redrawAll();
  };
  window.addEventListener("resize", doResize);
  doResize();

  for(const c of [idxCanvas, tseCanvas]){
    c.addEventListener("wheel", onWheelZoom, {passive:false});
    c.addEventListener("mousedown", (e)=>onMouseDown(e, c));
    c.addEventListener("mousemove", (e)=>{
      onMouseMove(e);
      if(!isDragging){
        const data = (c === idxCanvas ? idxData : tseData);
        showTooltipForCanvas(e, c, data);
      }
    });
    c.addEventListener("mouseup", onMouseUp);
    c.addEventListener("mouseleave", onMouseLeave);
  }
  window.addEventListener("mouseup", onMouseUp);

  autoLoad().catch(err=>{
    console.error(err);
    document.getElementById("status").textContent = `エラー: ${err.message}`;
  });
}
window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
